<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>汇编语言期末复习题库，答案与解析 | 木人舟的博客</title><meta name="author" content="木人舟"><meta name="copyright" content="木人舟"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言临时抱佛脚专用，拿着它速通汇编语言吧！😈😈，还有就是，答案与解析都是基于web search 的GenAL生成的，所以在计算题上会错误比较多，这个就自己想想办法吧，但是在概念与需要记忆的题上效果很好，自己作为参考吧😝😝😝 一 单选题第一章 PC机的最小信息单位是（ ）。  A. bit   B. 字节  C. 字长    D. 字  一个CPU的寻址能力是8KB，那么它的地址总线的宽">
<meta property="og:type" content="article">
<meta property="og:title" content="汇编语言期末复习题库，答案与解析">
<meta property="og:url" content="https://kashima19960.github.io/2024/10/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E9%A2%98%E5%BA%93%E7%AD%94%E6%A1%88%E4%B8%8E%E8%A7%A3%E6%9E%902024%E7%89%88/index.html">
<meta property="og:site_name" content="木人舟的博客">
<meta property="og:description" content="前言临时抱佛脚专用，拿着它速通汇编语言吧！😈😈，还有就是，答案与解析都是基于web search 的GenAL生成的，所以在计算题上会错误比较多，这个就自己想想办法吧，但是在概念与需要记忆的题上效果很好，自己作为参考吧😝😝😝 一 单选题第一章 PC机的最小信息单位是（ ）。  A. bit   B. 字节  C. 字长    D. 字  一个CPU的寻址能力是8KB，那么它的地址总线的宽">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/kashima19960/img@master/%E5%85%B6%E4%BB%96/86.jpg">
<meta property="article:published_time" content="2024-10-12T07:10:02.000Z">
<meta property="article:modified_time" content="2024-10-12T08:51:00.719Z">
<meta property="article:author" content="木人舟">
<meta property="article:tag" content="汇编语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/kashima19960/img@master/%E5%85%B6%E4%BB%96/86.jpg"><link rel="shortcut icon" href="https://cdn.pixabay.com/photo/2024/05/01/03/27/hands-8731277_640.png"><link rel="canonical" href="https://kashima19960.github.io/2024/10/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E9%A2%98%E5%BA%93%E7%AD%94%E6%A1%88%E4%B8%8E%E8%A7%A3%E6%9E%902024%E7%89%88/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 木人舟","link":"链接: ","source":"来源: 木人舟的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '汇编语言期末复习题库，答案与解析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-12 16:51:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/kashima19960/img@master/%E5%85%B6%E4%BB%96/86.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电源</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="木人舟的博客"><img class="site-icon" src="https://www.logosc.cn/oss/icons/2022/10/18/Yt1NwjSZdkXXe0s.png"/><span class="site-name">木人舟的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电源</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">汇编语言期末复习题库，答案与解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-12T07:10:02.000Z" title="发表于 2024-10-12 15:10:02">2024-10-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-12T08:51:00.719Z" title="更新于 2024-10-12 16:51:00">2024-10-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>76分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="汇编语言期末复习题库，答案与解析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>临时抱佛脚专用，拿着它速通汇编语言吧！😈😈，还有就是，答案与解析都是基于web search 的GenAL生成的，所以在计算题上会错误比较多，这个就自己想想办法吧，但是在概念与需要记忆的题上效果很好，自己作为参考吧😝😝😝</p>
<h2 id="一-单选题"><a href="#一-单选题" class="headerlink" title="一 单选题"></a>一 单选题</h2><h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><ol>
<li>PC机的最小信息单位是（ ）。</li>
</ol>
<p>A. bit   B. 字节  C. 字长    D. 字</p>
<ol start="2">
<li>一个CPU的寻址能力是8KB，那么它的地址总线的宽度为（ ）位。</li>
</ol>
<p>A. 8   B. 3   C. 12   D. 13</p>
<ol start="3">
<li>1个CPU的寻址能力为16KB，那么它的地址总线的宽度为 （  ）位。</li>
</ol>
<p>A. 11         B. 12         C. 13         D. 14</p>
<ol start="4">
<li>1MB的存储器的地址编号从（  ）到（  ）</li>
</ol>
<p>A.0<del>3ff H    B. 1</del>400 H         C. 0<del>fffff H  D. 1</del>100000H</p>
<ol start="5">
<li>1TB是 （  ） 个Byte。</li>
</ol>
<p>A. 2^40   B. 2^30   C. 2^20        D. 2^10</p>
<ol start="6">
<li>1MB是（  ） 个Byte。</li>
</ol>
<p>A. 2^40   B. 2^30   C. 2^20   D. 2^10</p>
<ol start="7">
<li>1KB的存储器的地址编号从（  ）到（  ）</li>
</ol>
<p>A. 0<del>3ff H        B. 1</del>400 H    C. 0<del>fffff H    D. 1</del>100000H</p>
<ol start="8">
<li>1KB的存储器的可以存储（  ）个bit</li>
</ol>
<p>A. 1024       B. 8×1024         C. 1000       D. 8000</p>
<ol start="9">
<li>1GB是 （  ） 个Byte。</li>
</ol>
<p>A. 2^40   B. 2^30   C. 2^20        D. 2^10</p>
<ol start="10">
<li>8086的数据总线宽度为16根，从内存中读取20字节的数据，8086至少要读 （  ）次。</li>
</ol>
<p>A. 16         B. 20          C. 10         D. 5</p>
<ol start="11">
<li>8086的数据总线宽度为32根。从内存中读取20字节的数据，8086至少要读 （  ）次。</li>
</ol>
<p>A. 32         B. 20          C. 10         D. 5</p>
<ol start="12">
<li>在存储器中,数据和程序以_______形式存放。</li>
</ol>
<p>A. 二进制    B. 八进制    C. 十进制    D. 十六进制</p>
<ol start="13">
<li>8086CPU的地址总线的宽度是20位，数据总线的宽度是16位，则8086CPU的寻址能力为(  )。</li>
</ol>
<p>A.64KB   B.1MB   C.1GB   D.不确定</p>
<ol start="14">
<li>8086CPU的地址总线宽度为32根，8086CPU的寻址能力是（  ）。</li>
</ol>
<p>A.64KB  B.1024KB  C.16MB   D.4096MB</p>
<ol start="15">
<li>从内存中读取1024个字节的数据，8086CPU至少需要读256次，则8086的数据总线宽度为（  ）位。</li>
</ol>
<p>A.4    B.8   C.16   D.32</p>
<ol start="16">
<li>8086中，一个字单元可以存储（  ）个bit。</li>
</ol>
<p>A.1  B.8  C.16   D.32</p>
<ol start="17">
<li>一个1KB的存储器包含多少个存储单元？可以存储多少个二进制位？（  ）</li>
</ol>
<p>A. 1024，1024  B. 8192，1024   C. 8192，8192   D. 1024，8192</p>
<h4 id="答案与解析"><a href="#答案与解析" class="headerlink" title="答案与解析"></a>答案与解析</h4><ol>
<li>PC机的最小信息单位是字节</li>
<li>一个CPU的寻址能力是8KB，那么它的地址总线的宽度为13位。因为13根地址总线可以寻址2^13&#x3D;8KB。</li>
<li>一个CPU的寻址能力为16KB，那么它的地址总线的宽度为14位。因为14根地址总线可以寻址2^14&#x3D;16KB。</li>
<li>1MB的存储器的地址编号从0x00000到0xFFFFF。1MB等于2^20字节，其十六进制表示为0x100000，因此地址范围为0x00000~0xFFFFF。</li>
<li>1TB是2^40个Byte。在计算机存储界，K、M、G、T为二进制单位，所以1TB&#x3D;1024GB&#x3D;1024<em>1024MB&#x3D;1024</em>1024<em>1024KB&#x3D;1024</em>1024<em>1024</em>1024Byte&#x3D;2^40Byte。</li>
<li>1MB是2^20个Byte。1MB&#x3D;1024KB&#x3D;1024*1024Byte&#x3D;2^20Byte。</li>
<li>1KB的存储器的地址编号从0x000到0x3FF。1KB等于2^10字节，其十六进制表示为0x400，因此地址范围为0x000~0x3FF。</li>
<li>1KB的存储器可以存储8192个bit。因为1KB&#x3D;1024Byte，而1Byte&#x3D;8bit，所以1KB&#x3D;1024*8bit&#x3D;8192bit。</li>
<li>1GB是2^30个Byte。1GB&#x3D;1024MB&#x3D;1024<em>1024KB&#x3D;1024</em>1024*1024Byte&#x3D;2^30Byte。</li>
<li>8086的数据总线宽度为16根，从内存中读取20字节的数据，8086至少要读10次。因为每次可以读取16位（即2字节），所以20字节需要10次读取。</li>
<li>8086的数据总线宽度为32根，从内存中读取20字节的数据，8086至少要读5次。因为每次可以读取32位（即4字节），所以20字节需要5次读取。</li>
<li>在存储器中，数据和程序以二进制形式存放。</li>
<li>8086CPU的地址总线的宽度是20位，数据总线的宽度是16位，则8086CPU的寻址能力为1MB。因为20位地址总线可以寻址2^20&#x3D;1MB。</li>
<li>8086CPU的地址总线宽度为32根，8086CPU的寻址能力是4GB。因为32位地址总线可以寻址2^32&#x3D;4GB。</li>
<li>从内存中读取1024个字节的数据，8086CPU至少需要读256次，则8086的数据总线宽度为32位。因为每次可以读取32位（即4字节），所以1024字节需要256次读取。</li>
<li>8086中，一个字单元可以存储16个bit。因为8086的数据总线宽度为16位，所以一个字单元是16位。</li>
<li>一个1KB的存储器包含1024个存储单元，可以存储8192个二进制位。因为1KB&#x3D;1024Byte，而1Byte&#x3D;8bit，所以1KB&#x3D;1024*8bit&#x3D;8192bit。</li>
</ol>
<h3 id="第2-3章"><a href="#第2-3章" class="headerlink" title="第2~3章"></a>第2~3章</h3><ol>
<li>在Debug中，用“d 075A：110 11F”查看内存，结果如下：</li>
</ol>
<p>075A：0110 B8 00  00 FF 07 00 B8 4C — CD 21 F3 69 20 8A 03 A1</p>
<p>那么，字型数据 00B8H对应的地址为（ ）。</p>
<p>A. 076A：11  B. 076A：16    C. 076B：0    D. 无法确定</p>
<ol start="2">
<li>给定段地址为1234H，仅通过变化偏移地址寻址，8086CPU的寻址范围为_________(物理地址）。</li>
</ol>
<p>A、 12340H<del>1234FH        B、 01234H</del>F1234H        C、 12340H<del>2233FH        D、 12340H</del>FFFFFH</p>
<ol start="3">
<li><p>给定段地址101H，仅通过变化偏移地址寻址，8086CPU可以寻址到地址为（ ）的内存单元。</p>
<p>A. 0   B. 12000H   C. 10000H   D. 1FFFFH</p>
</li>
<li><p>下列寄存器中，（  ）是8位寄存器。</p>
</li>
</ol>
<p>A、 AX        B、 BL       C、 CS           D、 DI</p>
<ol start="5">
<li>下列寄存器中，（ ）是16位寄存器</li>
</ol>
<p>A、 AX       B、 BL       C、 CH       D、 DL</p>
<ol start="6">
<li>下列说法正确的是（ ）</li>
</ol>
<p>A、 AX寄存器不能分为两个8位的寄存器</p>
<p>B、 BP寄存器不能分为两个8位的寄存器</p>
<p>C、 CS可以分为两个8位的寄存器</p>
<p>D、 PSW是一个通用寄存器，可以存放一般性的数据</p>
<ol start="7">
<li>下面指令中，错误的指令是（  ）。</li>
</ol>
<p>A、 MOV AX,1000             B、 MOV AL,BL</p>
<p>C、 MOV AL,1000             D、 MOV  DS,AX</p>
<ol start="8">
<li>下面指令中，错误的指令是（  ）。</li>
</ol>
<p>A、 MOV AX,100          B、 MOV BX,AL</p>
<p>C、 MOV AL,100          D、 ADD AL,BL</p>
<ol start="9">
<li>下面指令中，正确的指令是（  ）。</li>
</ol>
<p>A、 MOV AX,100          B、 MOV BX,AL</p>
<p>C、 MOV 100，AL        D、 ADD AL,1234H</p>
<ol start="10">
<li>下面的5条指令执行后，cpu几次修改IP？（ ）</li>
</ol>
<p>mov ax,2000H</p>
<p>mov bx,3000h</p>
<p>add ax,bx</p>
<p>sub bx,bx</p>
<p>jmp bx</p>
<p>A、 5        B、 6        C、 7        D、 不确定</p>
<ol start="11">
<li>代码段寄存器是（）</li>
</ol>
<p>A、 CS       B、 DS       C、 SS       D、 ES</p>
<ol start="12">
<li>指令指针寄存器是（）</li>
</ol>
<p>A、 AX       B、 BP       C、 IP        D、 DS</p>
<ol start="13">
<li>在debug中，查看、修改CPU的寄存器内容是（ ）命令。</li>
</ol>
<p>A、 T        B、 A        C、 E        D、 R</p>
<ol start="14">
<li>在debug中，查看内存中的内容是（ ）命令。</li>
</ol>
<p>A、 T        B、 A        C、 D        D、 R</p>
<ol start="15">
<li>在debug中，修改内存中的内容是（ ）命令。</li>
</ol>
<p>A、 T        B、 E        C、 D        D、 R</p>
<ol start="16">
<li>在debug中，执行CS、IP指向的内存单元处的指令是（ ）命令。</li>
</ol>
<p>A、 T        B、 E        C、 D        D、 R</p>
<ol start="17">
<li>存储单元45A0：7CB9H的物理地址为 （  ）</li>
</ol>
<p>A、 45AB9H      B、 4D6B9H       C、 C259H        D、 47CB9H</p>
<ol start="18">
<li>8086CPU中，任意时刻，CPU将（ ）指向的内容当作指令来执行。</li>
</ol>
<p>A. DS、SI   B. CS、IP   C. SS、SP   D. ES、DI</p>
<ol start="19">
<li>下列关于Debug的说法，错误的是（ ）。</li>
</ol>
<p>A. R命令可以修改寄存器的内容。   B. E命令可以修改内存单元的内容。</p>
<p>C. T命令每次只执行一条指令。    D. D命令可以查看内存单元的内容。</p>
<ol start="20">
<li>对于8086CPU，错误的指令是（  ）。</li>
</ol>
<p>A. mov ax,bx   B. mov ax,[bx]   C. mov ds,0   D. mov ax,0</p>
<ol start="21">
<li>以下指令执行后，寄存器ax的值为（  ）。</li>
</ol>
<p>mov ax, 0095h</p>
<p>mov ah, 95h</p>
<p>add al, ah</p>
<p>A. 9680H  B. 968AH   C. 962AH   D. 952AH</p>
<ol start="22">
<li>关于8086CPU，下列说法错误的是（  ）。</li>
</ol>
<p>A. 是16位结构的CPU，其能够一次性处理传输暂时存储的信息的最大长度是16bit</p>
<p>B. 采用“段地址×16 + 偏移地址 &#x3D; 物理地址”的方式生成存储单元的地址</p>
<p>C. 执行push指令和pop指令时，8086CPU从SS:SP中得到栈顶的地址</p>
<p>D. 在编程时，可将长度为1KB的一组地址连续，起始地址为32的倍数的内存单元当成栈空间来使用。</p>
<ol start="23">
<li>此时ax的值为00C5H，执行完“add al,85H”后，ax中的值是多少？（  ）</li>
</ol>
<p>A.0158H  B.014AH  C.0058H  D.004AH</p>
<ol start="24">
<li>关于汇编语言中“段”的概念，以下说法错误的是（  ）。</li>
</ol>
<p>A.用mov、add、sub等指令通过偏移地址访问data段中的数据前，应将data段的段地址放在ds中。</p>
<p>B.一个段，可以既是数据段，又是桟段。</p>
<p>C.一个段，不可以既是代码段，又是数据段。</p>
<p>D.一个段中的内容对CPU来说是指令还是数据，关键在于对相关寄存器的设置。</p>
<ol start="25">
<li>8086PC机一个段的最大长度为（  ）。</li>
</ol>
<p>A.64Byte  B.64Kbit  C.1MB  D.64KB</p>
<ol start="26">
<li>以下关于8086CPU的栈机制的说法，错误的是（  ）。</li>
</ol>
<p>A.任意时刻，SS:SP指向栈顶元素。</p>
<p>B.retf指令不会引起栈空间超界。</p>
<p>C.push和pop实质上是一种内存传送指令。</p>
<p>D.8086CPU的栈机制，没有对避免栈空间超界提供支持。</p>
<ol start="27">
<li>设置10000H～1FFFFH的内存空间为栈段，初始状态栈是空的，此时，SS、SP的值是（  ）。</li>
</ol>
<p>A.SS&#x3D;1000H、SP&#x3D;FFFEH        B.SS&#x3D;0H、SP&#x3D;FFFEH</p>
<p>C.SS&#x3D;1000H、SP&#x3D;0              D.SS&#x3D;2000H、SP&#x3D;0</p>
<ol start="28">
<li>完成同指令XCHG AX ,BX 相同功能的指令或指令序列是（  ）</li>
</ol>
<p>A、 MOV AX,BX</p>
<p>B、 MOV BX,AX</p>
<p>C、 PUSH AX</p>
<p>POP BX</p>
<p>D、 MOV CX,AX</p>
<p>MOV AX,BX</p>
<p>  MOV BX,CX</p>
<ol start="29">
<li>堆栈段段寄存器是（）</li>
</ol>
<p>A、 CS       B、 DS       C、 SS       D、 ES</p>
<ol start="30">
<li>堆栈指针寄存器是（）</li>
</ol>
<p>A、 BP       B、 SP       C、 SS       D、 IP</p>
<ol start="31">
<li>执行一次PUSH指令，SP寄存器将（ ）</li>
</ol>
<p>A、 加1          B、 减1          C、 加2          D、 减2</p>
<ol start="32">
<li>执行一次POP指令，SP寄存器将（ ）</li>
</ol>
<p>A、 加1          B、 减1          C、 加2          D、 减2</p>
<ol start="33">
<li>关于8086CPU堆栈，以下说法不正确的是（  ）</li>
</ol>
<p>A、 操作对象是字                       B、 堆栈的长度是没有限制</p>
<p>C、 任何时刻，SS:SP指向栈顶元素      D、 堆栈位于内存中</p>
<ol start="34">
<li>下面指令正确的是（ ）</li>
</ol>
<p>A、 POP AX          B、 POP 126CH      C、 PUSH AL         D、 PUSH AX,BX</p>
<ol start="35">
<li>8086系统中，一个堆栈最大可以设置为多少？（）</li>
</ol>
<p>A、 1MB         B、 1KB          C、 64KB          D、 64MB</p>
<ol start="36">
<li>如果要将20000h~21001h这段空间设置为堆栈，初始状态栈是空的，应该选择程序段（）。</li>
</ol>
<p>A、MOV SS,20000H</p>
<p>MOV SP,21001H</p>
<p>B、MOV AX,2000H</p>
<p>MOV SS,AX</p>
<p>MOV SP,1001H</p>
<p>C、 MOV AX,2000H</p>
<p>MOV SS,AX</p>
<p>MOV SP,1002H</p>
<p>D、 MOV AX,2000H</p>
<p>MOV SS,AX</p>
<p>MOV SP,1000H</p>
<ol start="37">
<li>设 SP初值为2000H，执行指令”PUSH AX”后，SP的值是（）</li>
</ol>
<p>A、 1FFFH             B、1998H         C、 2002H          D、1FFEH</p>
<ol start="38">
<li>在debug中，用“d 1000：0 0f”查看内存，结果如下。</li>
</ol>
<p>1000:0000  89 85 4C ED 38 7B F8 10 -29 8D 44 9D 3E 75 A8 20</p>
<p>若DS&#x3D;1000H，AX&#x3D;0，那么汇编指令“MOV  AL,[0008H]”执行完后AX 的值为</p>
<p>A、 0H     B、 2900H         C、 0029H        D、 0010H</p>
<ol start="39">
<li>在debug中，用“d 1000：0 0f”查看内存，结果如下。</li>
</ol>
<p>1000:0000  89 85 4C ED 38 7B F8 10 -29 8D 44 9D 3E 75 A8 20</p>
<p>DS&#x3D;1000H，AX&#x3D;0，那么汇编指令“MOV  AX,[0008H]”执行完后AX 的值为</p>
<p>A、 1029H        B、 298DH        C、 2910H        D、 8D29H</p>
<ol start="40">
<li>在debug中，用“d 1000：0 0f”查看内存，结果如下。</li>
</ol>
<p>1000:0000  89 85 4C ED 38 7B F8 10 -29 8D 44 9D 3E 75 A8 20</p>
<p>1000:0010  79 87 C4 EF 25 66 F7 40 -A9 BD C4 5D 6E 7F A1 2B</p>
<p>1000:0020  81 15 4D ED 83 B7 8F 1A -89 7D B6 9C 3E 73 A2 21</p>
<p>执行前DS&#x3D;0，AX&#x3D;0，BX&#x3D;0，那么执行下列汇编指令，完后AX 的值为（   ）</p>
<p>MOV AX,1002H</p>
<p>MOV DS,AX</p>
<p>MOV AX,[0]</p>
<p>A、 8589H        B、 8779H        C、 1581H        D、 8985H</p>
<ol start="41">
<li>在debug中，用“d 1000：0 0f”查看内存，结果如下。</li>
</ol>
<p>1000:0000  89 85 4C ED 38 7B F8 10 -29 8D 44 9D 3E 75 A8 20</p>
<p>1000:0010  79 87 C4 EF 25 66 F7 40 -A9 BD C4 5D 6E 7F A1 2B</p>
<p>1000:0020  81 15 4D ED 83 B7 8F 1A -89 7D B6 9C 3E 73 A2 21</p>
<p>执行前DS&#x3D;0，AX&#x3D;0，BX&#x3D;0，那么执行下列汇编指令，完后AX 的值为（   ）</p>
<p>MOV AX,1000H</p>
<p>MOV DS,AX</p>
<p>MOV AX,[0]</p>
<p>A、 8589H        B、 8779H        C、 1581H        D、 8985H</p>
<ol start="42">
<li><p>有以下几条指令（debug下的指令格式）：</p>
<p>mov ax,1000</p>
<p>mov ss,ax</p>
<p>mov sp,0100</p>
<p>mov ax,5CCA</p>
<p>push ax</p>
<p>指令“push ax”执行后，sp的值和修改的内存单元的地址是（  ）。</p>
</li>
</ol>
<p>A. 0100H，1000H：0100H   B. 00feH，1000H：00feH  C. 0100，1000：0100  D. 98，1000：98</p>
<ol start="43">
<li>如果将10000H~1FFFFH这段内存空间当做是栈空间，假设SS&#x3D;1000H，则下列说法正确的是（）。</li>
</ol>
<p>A.栈空的时候，SP的值为FFFEH     B.栈满的时候，SP的值为0</p>
<p>C.这段栈空间的大小为4KB       D.使用这段栈空间，有可能会出现栈越界</p>
<ol start="44">
<li>给定段地址为1001h，则8086CPu可以寻址到物理地址为（  ）的内存单元。</li>
</ol>
<p>A.0   B.20000H    C.10000H     D.20010H</p>
<ol start="45">
<li>CPU传递到地址总线上的地址是（  ）。</li>
</ol>
<p>A.逻辑地址   B.偏移地址  C.物理地址   D.段地址</p>
<ol start="46">
<li>关于8086CPU的几个寄存器，正确的说法是（  ）。</li>
</ol>
<p>A.可将BX当成两个8位寄存器，在偏移地址范围为0~255时，可以用“mov ax,[bl]”来实现将内存中的数据读到ax中</p>
<p>B.可以用“byte ptr”实现将SI当成两个8位寄存器使用</p>
<p>C.可将AX、BX、CX、DX当成8个8位寄存器使用</p>
<p>D.AX、ah、al是不同的寄存器，指令“add al,bl”的执行不会影响AX的值</p>
<ol start="47">
<li>下列与8086CPU寻址相关的说法，错误的是（  ）。</li>
</ol>
<p>A.8086CPU有20根地址总线，它的寻址能力为1MB</p>
<p>B.一个物理地址可以对应多个段地址与偏移地址</p>
<p>C.因为段寄存器是16位，所以一个段最大为64KB</p>
<p>D.CPU内部有一个能合成20位地址的地址加法器</p>
<ol start="48">
<li>以下指令执行后，SP的值为（  ）。</li>
</ol>
<p>mov sp,0</p>
<p>push ss</p>
<p>A.0   B.0fffeh    C.2    D.内存ss：0处的数据的值</p>
<ol start="49">
<li>用debug的e命令向b810：0010处写入数据，接着用d命令查看，发现b810：0010处并没有刚刚写入的数据，其原因是（  ）。</li>
</ol>
<p>A.此处用于存储系统时间，一直在自动更新</p>
<p>B.debug存在延时，第二次查看即可看到用e命令写入的数据</p>
<p>C.此处处于ROM空间，不可以被改变</p>
<p>D.此处处于显存空间，当屏幕刷新时，此处的数据被更新了</p>
<ol start="50">
<li>8086CPU中，如果某内存单元的物理地址为4FCE0，其段地址和偏移地址一定不会是（  ）。</li>
</ol>
<p>A.4FC0：00E0 B.4CE0：2EE0 C.40CE：0F00 D.40C0：F0E0</p>
<ol start="51">
<li>以下指令执行后，AX寄存器的值是（  ）。</li>
</ol>
<p>mov ax,017ch</p>
<p>add al,0b4h</p>
<p>A.0130H      B.0230H      C.012FH      D.022FH</p>
<h4 id="答案与解析-1"><a href="#答案与解析-1" class="headerlink" title="答案与解析"></a>答案与解析</h4><ol>
<li>076B:0,和075A:0110是等价的，自己算算就知道了</li>
<li>8086CPU的寻址范围为 <code>12340H</code> 到 <code>2233fH</code>。</li>
<li>给定段地址 <code>101H</code>，8086CPU可以寻址到地址为 &#96;10000H</li>
<li>8位寄存器包括 <code>BL</code>。其他选项如 <code>AX</code>、<code>CS</code>、<code>DI</code> 都是16位寄存器。</li>
<li>16位寄存器包括 <code>AX</code>。其他选项如 <code>BL</code>、<code>CH</code>、<code>DL</code> 都是8位寄存器。</li>
<li>正确的说法是 <code>AX寄存器不能分为两个8位的寄存器</code>。其他选项不正确，因为 <code>BP</code> 和 <code>CS</code> 不能分为两个8位的寄存器，而 <code>PSW</code> 是一个特殊的寄存器，用于存放标志位，不是通用寄存器。</li>
<li>错误的指令是 <code>MOV AL,1000</code>。因为 <code>AL</code> 是8位寄存器，不能直接加载16位的立即数。</li>
<li>错误的指令是 <code>MOV BX,AL</code>。因为 <code>BX</code> 是16位寄存器，不能直接从8位寄存器 <code>AL</code> 获取数据。</li>
<li>正确的指令是 <code>MOV AX，100</code>。</li>
<li>执行这5条指令后，CPU会修改IP 6次。这是因为每次修改指令指针 <code>IP</code> 或代码段寄存器 <code>CS</code> 都会导致IP的修改。</li>
<li>代码段寄存器是 <code>CS</code>。</li>
<li>指令指针寄存器是 <code>IP</code>。</li>
<li>在debug中，查看、修改CPU的寄存器内容是 <code>R</code> 命令。</li>
<li>在debug中，查看内存中的内容是 <code>D</code> 命令。</li>
<li>在debug中，修改内存中的内容是 <code>E</code> 命令。</li>
<li>在debug中，执行CS、IP指向的内存单元处的指令是 <code>T</code> 命令。</li>
<li>存储单元 <code>45A0：7CB9H</code> 的物理地址为 <code>4D6B9H</code>。这是通过将段地址 <code>45A0H</code> 乘以16（即左移4位）然后加上偏移地址 <code>7CB9H</code> 得到的。</li>
<li>8086CPU中，任意时刻，CPU将 <code>CS、IP</code> 指向的内容当作指令来执行。</li>
<li>这道题选c，t命令是单步中断，并不是一次只执行一个指令</li>
<li>对于8086CPU，错误的指令是 <code>mov ds,0</code>。因为 <code>DS</code> 是段寄存器，不能直接用立即数进行赋值。</li>
<li>执行这些指令后，寄存器 <code>AX</code> 的值为 <code>962AH</code>。首先，<code>mov ax, 0095h</code> 将 <code>AX</code> 设置为 <code>0095H</code>。接着，<code>mov ah, 95h</code> 将 <code>AH</code> 设置为 <code>95H</code>，但由于 <code>AH</code> 是 <code>AX</code> 的高8位，因此 <code>AX</code> 实际上变成了 <code>9595H</code>。最后，<code>add al, ah</code> 将 <code>AL</code>（即 <code>AX</code> 的低8位）和 <code>AH</code> 相加，结果为 <code>12AH</code>，最后 <code>AX</code> 的值为 962AH&#96;。</li>
<li>关于8086CPU，错误的说法是 <code>D. 在编程时，可将长度为1KB的一组地址连续，起始地址为32的倍数的内存单元当成栈空间来使用</code>。8086CPU的栈空间没有特定的起始地址要求，只要保证栈空间的连续性和正确设置栈指针即可。</li>
<li><code>AX</code> 的初始值为 <code>00C5H</code>，执行 <code>add al, 85H</code> 后，<code>AX</code> 中的值是 <code>014AH</code>。这是因为 <code>AL</code>（<code>AX</code> 的低8位）原本是 <code>C5H</code>，加上 <code>85H</code> 后得到 <code>14AH</code>，<code>AH</code>（<code>AX</code> 的高8位）保持不变。</li>
<li>关于汇编语言中“段”的概念，错误的说法是 <code>C. 一个段，不可以既是代码段，又是数据段</code>。在汇编语言中，一个段可以同时用作代码段和数据段。</li>
<li>8086PC机一个段的最大长度为 <code>64KB</code>。</li>
<li>选B，retf是利用了堆栈的，原因自己看书!</li>
<li>设置 <code>10000H～1FFFFH</code> 的内存空间为栈段，初始状态栈是空的，此时，<code>SS</code>、<code>SP</code> 的值是 <code>SS=1000H</code>、<code>SP=FFFEH</code>。</li>
<li>完成同指令 <code>XCHG AX, BX</code> 相同功能的指令或指令序列是 <code>D. MOV CX, AX; MOV AX, BX; MOV BX, CX</code>。这组指令首先将 <code>AX</code> 的值暂存到 <code>CX</code>，然后将 <code>AX</code> 和 <code>BX</code> 交换，最后将暂存的值从 <code>CX</code> 恢复到 <code>BX</code>。</li>
<li>堆栈段段寄存器是 <code>SS</code>。</li>
<li>堆栈指针寄存器是 <code>SP</code>。</li>
<li>执行一次 <code>PUSH</code> 指令，<code>SP</code> 寄存器将 <code>减2</code>。</li>
<li>执行一次 <code>POP</code> 指令，<code>SP</code> 寄存器将 <code>加2</code>。</li>
<li>关于8086CPU堆栈，不正确的说法是 <code>B. 堆栈的长度是没有限制</code>。实际上，堆栈的长度是有限的，取决于可用内存的大小。</li>
<li>下面指令正确的是 <code>A. POP AX</code>。</li>
<li>8086系统中，一个堆栈最大可以设置为 <code>64KB</code>。</li>
<li>选c，sp的值要比栈底大1，细节自己看书</li>
<li>设 <code>SP</code> 初值为 <code>2000H</code>，执行指令 “PUSH AX” 后，<code>SP</code> 的值是 <code>1FFEH</code>。这是因为 <code>AX</code> 是一个字，所以 <code>PUSH AX</code> 将 <code>AX</code> 的值压入栈，<code>SP</code> 减少2。</li>
<li>0029H</li>
<li>8D29H</li>
<li>1581H,1002H与1000:20等价，自己看看在哪个位置就行</li>
<li>在 <code>debug</code> 中，用 “d 1000：0 0f” 查看内存，结果如下。执行前 <code>DS=0</code>，<code>AX=0</code>，<code>BX=0</code>，那么执行下列汇编指令后 <code>AX</code> 的值为 <code>8589H</code>。这是因为 <code>MOV AX, 1000H</code> 将 <code>AX</code> 设置为 <code>1000H</code>，然后 <code>MOV DS, AX</code> 将数据段寄存器 <code>DS</code> 设置为 <code>1000H</code>。接着 <code>MOV AX,[0]</code> 将 <code>[0]</code> 处的值加载到 <code>AX</code> 中，即 <code>8589H</code>。</li>
<li>指令 “push ax” 执行后，<code>SP</code> 的值和修改的内存单元的地址是 <code>B. 00feH，1000H：00feH</code>。这是因为 <code>SP</code> 在执行 <code>push ax</code> 指令前为 <code>0100H</code>，执行后 <code>SP</code> 减1变为 <code>00feH</code>。修改的内存单元地址为 <code>1000H：00feH</code>，因为 <code>SS</code> 为 <code>1000H</code>，<code>SP</code> 为 <code>00feH</code>。</li>
<li>如果将 <code>10000H～1FFFFH</code> 这段内存空间当做是栈空间，假设 <code>SS=1000H</code>，则正确的说法是  <code>D. 使用这段栈空间，有可能会出现栈越界</code>。</li>
<li>给定段地址为 <code>1001h</code>，则8086CPU可以寻址到物理地址为 <code>10000H</code> 的内存单元。</li>
<li>CPU传递到地址总线上的地址是 <code>C. 物理地址</code>。</li>
<li>C.可将AX、BX、CX、DX当成8个8位寄存器使用</li>
<li>下列与8086CPU寻址相关的说法，错误的是 <code>C. 因为段寄存器是16位，所以一个段最大为64KB</code></li>
<li>以下指令执行后，<code>SP</code> 的值为 <code>A. 0</code>。这是因为 <code>mov sp,0</code> 将 <code>SP</code> 设置为 <code>0</code>，然后 <code>push ss</code> 将 <code>SS</code> 的值压入栈，由于 <code>SP</code> 已经是 <code>0</code>，所以栈溢出，<code>SP</code> 保持不变。</li>
<li>用 <code>debug</code> 的 <code>e</code> 命令向 <code>b810：0010</code> 处写入数据，接着用 <code>d</code> 命令查看，发现 <code>b810：0010</code> 处并没有刚刚写入的数据，其原因是 <code>D. 此处处于显存空间，当屏幕刷新时，此处的数据被更新了</code>。</li>
<li>8086CPU中，如果某内存单元的物理地址为 <code>4FCE0</code>，其段地址和偏移地址一定不会是 <code>D. 40C0：F0E0</code>。这是因为 <code>40C0H</code> 不是 <code>4FCE0</code> 的有效段地址，且 <code>F0E0</code> 不是 <code>4FCE0</code> 的有效偏移地址。</li>
<li>0230H，选B</li>
</ol>
<h3 id="第4-6章"><a href="#第4-6章" class="headerlink" title="第4~6章"></a>第4~6章</h3><ol>
<li>一个汇编源程序，从写出到最后被CPU执行，依次经历了哪几步？（  ）</li>
</ol>
<p>A.编译、加载、连接、执行    B.加载、编译、连接、执行</p>
<p>C.连接、编译、加载、执行    D.编译、连接、加载、执行</p>
<ol start="2">
<li>关于编译和连接，错误的说法是（  ）。</li>
</ol>
<p>A.编译产生的*.obj文件不能在操作系统下直接运行</p>
<p>B.连接产生的*.exe文件里面没有伪指令</p>
<p>C.编译可以检查出语法错误</p>
<p>D.连接可以检查出逻辑错误</p>
<ol start="3">
<li><p>源程序中有如下两个按先后顺序定义的段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a segment </span><br><span class="line">db 1,2,3,4,5,6,7,8 </span><br><span class="line">a ends </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b segment  </span><br><span class="line">db 1,2,3,4,5,6,7,8 </span><br><span class="line">b ends </span><br></pre></td></tr></table></figure>

<p>如果a段中“1” 这个数据的物理地址是X，则b段中“1”这个数据的物理地址是（  ）。</p>
<p>A. X   B. X+1   C. X+16    D. X+64</p>
</li>
<li><p>Debug加载程序后，假设PSP的段地址为SA，偏移地址为0，则程序的起始地址是（ ）。</p>
</li>
</ol>
<p>A. SA×16H  B. SA×16   C. (SA+16H)×16H   D. (SA+16)×16</p>
<ol start="5">
<li>下列关于汇编语言源程序的说法，错误的是（ ）</li>
</ol>
<p>A. 一个汇编语言源程序从写出到执行需经过.编写.asm文件→将.asm文件编译为.obj文件→将.obj文件连接成.exe文件→.exe文件执行。</p>
<p>B. 在汇编语言源程序中，包含三种指令：汇编指令、伪指令、其他符号。</p>
<p>C. 在汇编语言源程序中，不由编译器执行的伪指令有对应的机器指令。</p>
<p>D. 在汇编语言源程序中，汇编指令是有对应机器码的指令，其所对应的机器指令由CPU执行。</p>
<pre><code>``assembly       mov ax,4c00h       Int 21h       ``
</code></pre>
<p>CPU执行完这两条指令后，（  ）。</p>
<p>A. 返回到DOS   B. 返回到DEBUG   C. 返回到COMMOND    D. 前三个选项都不对</p>
<ol start="7">
<li>下列说法正确的是（  ）。</li>
</ol>
<p>A. 代码段中的信息都会被当做指令执行</p>
<p>B. CS：IP指向过的指令一定被CPU执行过</p>
<p>C. 用Debug的t命令，一次只能执行一条汇编指令</p>
<p>D. 通过“ASSUME”建立的段与段寄存器之间的关联是编译器要处理的</p>
<ol start="8">
<li>执行下面的指令后，正确的结果是（  ）。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov al,198</span><br><span class="line"></span><br><span class="line">and al, 01010011B </span><br><span class="line"></span><br><span class="line">or al,01010101B</span><br></pre></td></tr></table></figure>

<p>A. al &#x3D; 57   B. al &#x3D; 57H   C. al &#x3D; 42    D. al &#x3D; 42H</p>
<ol start="9">
<li>需要使用DS的指令是（  ）。</li>
</ol>
<p>A. mov ax,[bp]  B. inc word ptr [bx]   C. add al,cl   D. and [bp],al</p>
<ol start="10">
<li><pre><code class="assembly">data segment
dd 1234h
data ends
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">data段中的数据1234h在内存中的存储情况为（  ）。</span><br><span class="line"></span><br><span class="line">A. 12 34 00 00   B. 34 12 00 00   C. 00 00 12 34   D. 00 00 34 12</span><br><span class="line"></span><br><span class="line">11. BIOS存储在下列哪种硬件中？（  ）</span><br><span class="line"></span><br><span class="line">A.   RAM  B.ROM  C.CPU  D.CMOS</span><br><span class="line"></span><br><span class="line">12. 主板生产日期存储在下列哪种硬件中？（  ）</span><br><span class="line"></span><br><span class="line">A.RAM  B.ROM  C.CPU  D.CMOS</span><br><span class="line"></span><br><span class="line">13. 用 [di]、[bp]的方式访问内存时，8086CPU默认的段寄存器依次是（  ）。</span><br><span class="line"></span><br><span class="line">A.ds、es   B.ds、ss  C.ss、ds  D.es、ss</span><br><span class="line"></span><br><span class="line">14. 在debug中查看内存，显示如下：</span><br><span class="line"></span><br><span class="line">073F：0000   CD 20 3E A7 00 EA FD FF-AD DE 4F 03 A3 01 8A 03</span><br><span class="line"></span><br><span class="line">073F：0010   A3 01 17 03 A3 01 92 01-01 01 01 00 02 FF FF FF</span><br><span class="line"></span><br><span class="line">073FH：0013H处的字型数据是（  ）。</span><br><span class="line"></span><br><span class="line">A.007AH   B.03A3H  C.A303H   D.0317H</span><br><span class="line"></span><br><span class="line">15. 对于8086CPU，正确的指令是（ ）。</span><br><span class="line"></span><br><span class="line">A.mov ax,[bp+dx]    B.mov ax,ds.[bp+bx]</span><br><span class="line"></span><br><span class="line">C.mov ax,ss：[si][di]  D.mov ax,cs.6[si]</span><br><span class="line"></span><br><span class="line">16. 可以修改CX的指令是（  ）。</span><br><span class="line"></span><br><span class="line">A.jmp  B.div  C.shl  D.jcxz</span><br><span class="line"></span><br><span class="line">17. 关于标号，错误的说法是（  ）。</span><br><span class="line"></span><br><span class="line">A.数据标号表示了内存单元的地址和长度。</span><br><span class="line"></span><br><span class="line">B.后边加“：”的地址标号，只能在代码段中使用。</span><br><span class="line"></span><br><span class="line">C.应用assume将指令中的数据标号所在的段，与一个段寄存器联系起来，这样，使用数据标号的指令，就可以从段寄存器中得到所用数据标号的段地址。</span><br><span class="line"></span><br><span class="line">D.可以将一个标号集合存储在直接定址表中。</span><br><span class="line"></span><br><span class="line">18. 关于PSP，错误的说法是（  ）。</span><br><span class="line"></span><br><span class="line">A.这个程序设置(CS)*16+(IP)= PSP所在内存空间的首地址。</span><br><span class="line"></span><br><span class="line">```assembly</span><br><span class="line">assume cs：code</span><br><span class="line">code segment </span><br><span class="line">start： mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es：[200h],0</span><br><span class="line">mov es：[202h],ds</span><br><span class="line">jmp dword ptr es：[200h]</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p>B.PSP共有256个字节。</p>
<p>C.DOS通过PSP来与其所加载的程序进行通信。</p>
<p>D.用debug加载一个其功能是设置(ds)&#x3D;(cs)的程序后，即用a命令写且用T命令运行以下程序段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,ds</span><br><span class="line">sub ax,10</span><br><span class="line">mov ds,ax</span><br></pre></td></tr></table></figure>

<p>之后用“d ds：0 ff”，可对PSP所在的内存空间进行查看。</p>
<ol start="19">
<li>以下指令执行后，ax的值是（  ）。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,6776h</span><br><span class="line"></span><br><span class="line">add al,90h</span><br><span class="line"></span><br><span class="line">add ah,90h</span><br></pre></td></tr></table></figure>

<p>A.6806H  B.F806H   C.F706H    D.6706H</p>
<ol start="20">
<li>以下指令执行后，al的值是多少？（  ）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov al,01100011b</span><br><span class="line"></span><br><span class="line">and al,00111011b</span><br><span class="line"></span><br><span class="line">or al,00111011b</span><br></pre></td></tr></table></figure>

<p>A.00100011B   B.00111011B   C.01111011B   D.前三个选项都不对。</p>
<ol start="21">
<li>以下程序运行时，源程序的指令中，CPU执行的第一条指令是？（  ）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">assume cs：a</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">mov ax,20h</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line"></span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">a segment</span><br><span class="line"></span><br><span class="line">mov bx,30h</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line"></span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b segment</span><br><span class="line"></span><br><span class="line">mov bx,40h</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line"></span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>A.mov ax,20h   B.mov bx,30h  C.mov bx,40h    D.以上选项都不对</p>
<ol start="22">
<li>对于8086CPU，正确的指令是（  ）。</li>
</ol>
<p>A.INC WORD PTR DS：[0]      B.MOV ES：[0],DS：[0]</p>
<p>C.MOV AX,[BX+BP]         D.ADD CS,AX</p>
<ol start="23">
<li>按照地址从低到高的顺序排列，双字型数据16在内存中如何存储？（  ）</li>
</ol>
<p>A.00 00 10 00    B.00 00 00 10</p>
<p>C.00 10 00 00    D.10 00 00 00</p>
<ol start="24">
<li>不可能出现在可执行文件中的是（  ）。</li>
</ol>
<p>A.机器码    B.伪指令  C.源程序中定义的数据  D.JMP指令中的地址</p>
<ol start="25">
<li>关于在程序中使用内存空间，不正确的说法是（  ）。</li>
</ol>
<p>A.可以通过定义段的方式给程序分配安全的内存空间</p>
<p>B.DOS和应用程序一般不会使用0.200~0.2FF这段空间</p>
<p>C.使用安全的内存空间，不会影响DOS操作系统和其他合法程序的运行</p>
<p>D.使用MOV指令时，不用担心损坏系统数据</p>
<ol start="26">
<li>以下指令中，可以被CPU执行的指令是（  ）。</li>
</ol>
<p>A.SEGMENT   B.ASSUME   C.STI    D.END</p>
<ol start="27">
<li>CPU在读取指令时，实际读到的是什么？（  ）</li>
</ol>
<p>A.伪指令和汇编指令所对应的字符串</p>
<p>B.用汇编语言写的源程序中的信息</p>
<p>C.由一系列二进制位组成的信息</p>
<p>D.汇编指令所对应的字符串</p>
<ol start="28">
<li>对于8086CPU，错误的指令是（  ）。</li>
</ol>
<p>A.mov ax,ds    B.push [bx]     C.inc [bx]     D.add bp,2</p>
<ol start="29">
<li>对于8086CPU，下列关于段的说法，错误的是（  ）。</li>
</ol>
<p>A.一个段的起始地址必须是16的整数倍</p>
<p>B.在源程序中定义一个段，在运行程序时，CPU不会因此定义而知道这个段的大小。</p>
<p>C.一块内存空间可以既是代码段，又是数据段。</p>
<p>D.CPU将某个段用做栈，是因为assume指令将其与SS寄存器相关联</p>
<ol start="30">
<li>（  ）的功能与“mov al,’d’”的 功能相同。</li>
</ol>
<p>A.mov ax,’d’   B.mov al,’a’+3   C.mov al,’A’+3   D.or al,’d’</p>
<ol start="31">
<li>关于汇编语言中的指令，正确的说法是（  ）。</li>
</ol>
<p>A.汇编语言中的标号属于伪指令</p>
<p>B.汇编指令一定有对应的机器码</p>
<p>C.伪指令由编译器识别，编译器将其转化为对应的机器码</p>
<p>D.“+”一般会被编译成add指令</p>
<ol start="32">
<li>以下程序运行时，“sub ax,masm”执行后，ax的值是（  ）。</li>
</ol>
<p>assume cs：code</p>
<p>masm segment</p>
<p>dw 5 dup(‘a’,’b’,’c’)</p>
<p>masm ends</p>
<p>code segment</p>
<p>start： mov ax,code</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sub ax,masm</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line"></span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure>

<p>code ends</p>
<p>end start</p>
<p>A.15    B.1    C.2   D.3</p>
<ol start="33">
<li>关于debug的使用，错误的说法是（  ）。</li>
</ol>
<p>A.Debug将程序加载到内存后，不执行任何命令前，IP的值一定为零</p>
<p>B.通过debug可以查看标志寄存器某些位的值</p>
<p>C.Debug将程序加载到内存后，不执行任何命令前，CX的值有可能是1024</p>
<p>D.T命令有可能一次执行一条以上的指令</p>
<ol start="34">
<li>关于标号，下列说法正确的是（  ）。</li>
</ol>
<p>A.   地址标号和数据标号都可以在jmp后使用</p>
<p>B.   后面带“：”的标号，用在代码段中是地址标号，用在数据段中是数据标号</p>
<p>C.   用在代码段中的数据标号只表示内存单元的地址</p>
<p>D.   在and与or指令中不可用地址标号</p>
<p>E.   前几个选项都不对</p>
<ol start="35">
<li>汇编语言中不包括哪个元素？（  ）</li>
</ol>
<p>A.汇编指令</p>
<p>B.机器指令</p>
<p>C.伪指令</p>
<p>D.“+”、“-”、“*”、“&#x2F;”等符号</p>
<ol start="36">
<li>对于编译、连接、运行，错误的说法是（  ）。</li>
</ol>
<p>A.伪指令在编译的过程中被编译器执行了</p>
<p>B.使用masm编译器进行编译，只能生成目标文件</p>
<p>C.可执行文件中包含程序和描述信息</p>
<p>D.DOS提供的command程序可以将可执行文件中的程序加载进内存</p>
<ol start="37">
<li>以下说法中，错误的是（  ）。</li>
</ol>
<p>A.在用masm.exe编译的汇编语言的源程序中，end和ends都属于伪指令</p>
<p>B.在debug中调试一个程序，在用p命令依次执行程序中的“mov ax,4c00h”与</p>
<p>“int 21h”两条指令后，屏幕上显示“Program terminated normally”，可说明此</p>
<p>时程序已返回到DOS</p>
<p> C.用于程序返回的相关指令是CPU来执行的</p>
<p> D.对于程序返回，DOS提供了相应的中断例程</p>
<ol start="38">
<li>用debug写几条指令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,20</span><br><span class="line"></span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov ax,[1]</span><br></pre></td></tr></table></figure>

<p>  之后查看内存，显示如下：</p>
<p>0：200 80 00 70 00 60 00 ……</p>
<p>接着用t命令执行这几条指令，“mov ax,[1]”执行后，AX的值是多少？（  ）</p>
<p> A.7000H      B.0070H      C.1            D.0080H</p>
<ol start="39">
<li><p>以下指令执行后，AX的值是多少？（  ）</p>
<p>mov ax,20</p>
<p>mov es,ax</p>
<p>mov byte ptr es：[0],80h</p>
<p>mov byte ptr es：[1],00h</p>
<p>mov byte ptr es：[2],70h</p>
<p>mov byte ptr es：[3],00h<br>mov ax,es：[1]</p>
</li>
</ol>
<p>  A.7000H           B.0070H           C.1            D.0080H</p>
<ol start="40">
<li><p>汇编语言源程序中的“dw”、“db”、“dd”等指令属于（  ）。</p>
<p>A.汇编指令        B.伪指令     C.机器指令        D.标号</p>
</li>
<li><p>对于程序的执行过程，错误的说法是（  ）。</p>
<p>A.通过command将程序加载进内存后，command将根据可执行文件中的描述信息，设置CS.IP指向第一条要执行的指令</p>
<p>B.通过debug将程序加载进内存后，用r命令查看CX的值，可看到与程序的长度相关的信息</p>
<p>C.通过debug将程序加载进内存后，DS指向程序的数据段，CS指向程序的代码段</p>
<p>D.在源程序中用end指令，可以决定程序加载后IP寄存器的值</p>
</li>
<li><p>下列对于程序段前缀（PSP）的描述，错误的是（  ）。</p>
</li>
</ol>
<p>A.PSP占256个字节的地址空间</p>
<p>B.DOS通过PSP与被加载的程序通信</p>
<p>C.用debug将程序载入内存后，PSP与代码段的段地址一致，偏移地址相差100h</p>
<p>D.用debug将程序载入内存后，可用“d ds：0 ff”查看PSP的全部内容</p>
<ol start="43">
<li>下面汇编语言源程序中的指令可以通过编译的是（  ）。</li>
</ol>
<p>A. mov al,2000  B. push [0]  C. add al,100h  D. mov dx,1000h</p>
<ol start="44">
<li>下列说法正确的是（  ）。</li>
</ol>
<p>A. Push、pop指令通过修改ss：sp的值来操作栈中的数据</p>
<p>B. 栈空时，ss：sp指向栈底</p>
<p>C. 栈满以后，如果继续向其中压入数据，会覆盖栈顶之后的高地址内存单元</p>
<p>D. 栈满以后，如果继续向其中压入数据，不一定会覆盖其地址比栈顶的地址更低的内存单元</p>
<ol start="45">
<li>其所传送的数据在内存中的指令是（  ）。</li>
</ol>
<p>A. pop ax  B. mov ax,bx  C. mov ax,0  D. in al,20h</p>
<ol start="46">
<li>以下程序加载后，在执行前，(ds)&#x3D;0a21h。对于此时的寄存器与程序的相关情况，错误的说法是（  ）。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">assume cs：code,ds：data</span><br><span class="line"></span><br><span class="line">  data segment</span><br><span class="line"></span><br><span class="line">  db ’1975’</span><br><span class="line"></span><br><span class="line">  data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah</span><br><span class="line"></span><br><span class="line">mov ax,0</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line"></span><br><span class="line">s： add ax,cs：[bx]</span><br><span class="line"></span><br><span class="line">add bx,2</span><br><span class="line"></span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">  mov ax,4c00h</span><br><span class="line"></span><br><span class="line">  int 21h</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>A. 程序的起始段地址为0a31h</p>
<p>B. (cs)&#x3D;0a31h，(ip)&#x3D;0</p>
<p>C. ds的值不是data段的段地址</p>
<p>D. “mov ax,0”的机器码的内存地址是0a31H：0020H</p>
<ol start="47">
<li>masm和debug默认的进制分别是（  ）。</li>
</ol>
<p>A.十六进制和十进制    B.十进制和二进制</p>
<p>C.十进制和十六进制    D.二进制和十六进制</p>
<ol start="48">
<li>补全这段程序，使其执行后，(bx)&#x3D;3。（  ）</li>
</ol>
<p>mov bx,1</p>
<p>mov cx,___</p>
<p>loop s1</p>
<p>mov bx,2</p>
<p>s1： inc bx</p>
<p>A. 0   B. 1  C. 2  D. 3</p>
<h4 id="答案与解析-2"><a href="#答案与解析-2" class="headerlink" title="答案与解析"></a>答案与解析</h4><ol>
<li>D.编译、连接、加载、执行</li>
<li>D.连接可以检查出逻辑错误</li>
<li>C. X+16</li>
<li>D. (SA+16)×16</li>
<li>C. 在汇编语言源程序中，不由编译器执行的伪指令有对应的机器指令</li>
<li>A. 返回到DOS</li>
<li>C. 用Debug的t命令，一次只能执行一条汇编指令</li>
<li>B. al &#x3D; 57H</li>
<li>B。bp这个寄存器对应的段寄存器不是DS</li>
<li>B. 34 12 00 00</li>
<li>B.ROM</li>
<li>B。ROM</li>
<li>B.ds、ss</li>
<li>B.03A3H</li>
<li>A.mov ax,[bp+dx]</li>
<li>C.shl</li>
<li>C.应用assume将指令中的数据标号所在的段，与一个段寄存器联系起来，这样，使用数据标号的指令，就可以从段寄存器中得到所用数据标号的段地址。</li>
<li>A.这个程序设置(CS)16+(IP)&#x3D; PSP所在内存空间的首地址。</li>
<li>B.F806H</li>
<li>B.00111011B</li>
<li>CPU执行的第一条指令是 mov ax,20h1.</li>
<li>对于8086CPU，正确的指令是 INC WORD PTR DS:[0]</li>
<li>双字型数据16在内存中的存储方式是 00 00 00 10</li>
<li>不可能出现在可执行文件中的是 伪指令</li>
<li>关于在程序中使用内存空间，不正确的说法是 使用MOV指令时，不用担心损坏系统数据</li>
<li>以下指令中，可以被CPU执行的指令是 STI</li>
<li>CPU在读取指令时，实际读到的是 由一系列二进制位组成的信息</li>
<li>对于8086CPU，错误的指令是 mov ax,ds</li>
<li>对于8086CPU，下列关于段的说法，错误的是 CPU将某个段用做栈，是因为assume指令将其与SS寄存器相关联</li>
<li>功能与“mov al,’d’”的 功能相同的是 mov al,’a’+310</li>
<li>关于汇编语言中的指令，正确的说法是 汇编指令一定有对应的机器码</li>
<li>以下程序运行时，“sub ax,masm”执行后，ax的值是15</li>
<li>关于debug的使用，错误的说法是 Debug将程序加载到内存后，不执行任何命令前，IP的值一定为零</li>
<li>关于标号，下列说法正确的是 前几个选项都不对</li>
<li>汇编语言中不包括哪个元素？答案是 “+”、“-”、“*”、“&#x2F;”等符号</li>
<li>对于编译、连接、运行，错误的说法是 伪指令在编译的过程中被编译器执行了</li>
<li>以下说法中，错误的是 在用masm.exe编译的汇编语言的源程序中，end和ends都属于伪指令</li>
<li>用debug写几条指令后，“mov ax,1”执行后，AX的值是 0070H</li>
<li>以下指令执行后，AX的值是 0080H</li>
<li>汇编语言源程序中的“dw”、“db”、“dd”等指令属于 伪指令</li>
<li>通过debug将程序加载进内存后，DS指向程序的数据段，CS指向程序的代码段（DS指向程序的psp，执行装填指令才有正确的段地址）</li>
<li>下列对于程序段前缀（PSP）的描述，错误的是 用debug将程序载入内存后，PSP与代码段的段地址一致，偏移地址相差100h</li>
<li>下面汇编语言源程序中的指令可以通过编译的是D</li>
<li>C. 栈满以后，如果继续向其中压入数据，会覆盖栈顶之后的高地址内存单元</li>
<li>其所传送的数据在内存中的指令是 mov ax,025.</li>
<li>D. “mov ax,0”的机器码的内存地址是0a31H：0020H</li>
<li>masm和debug默认的进制分别是 十进制和十六进制</li>
<li>补全这段程序，使其执行后，(bx)&#x3D;3的答案是 2</li>
</ol>
<h3 id="第7-8章（寻址方式）"><a href="#第7-8章（寻址方式）" class="headerlink" title="第7-8章（寻址方式）"></a>第7-8章（寻址方式）</h3><ol>
<li>以下寻址方式中，属于相对基址变址寻址的是（  ）。</li>
</ol>
<p>A. [bx+si+idata]    B. [bx+di]    C. [bp+si]    D. [bx]</p>
<ol start="2">
<li>可在基址变址寻址或寄存器间接寻址中，用作偏移地址寄存器的是（  ）。</li>
</ol>
<p>A. ax，bx，cx，dx    B. ds，es，cs，ss</p>
<p>C. sp，bp，ip，bx    D. si，di，bp，bx</p>
<ol start="3">
<li>用“dd 5 dup (1,2,3,4)”说明的数据，在程序运行时，共占用（  ）个字节。</li>
</ol>
<p>A. 4  B. 20  C. 40  D. 80</p>
<ol start="4">
<li>对于8086CPU，错误的指令是（  ）。</li>
</ol>
<p>A. mov ax,[bp+si]  B. mov ax,[bx]  C. mov ax,2[si]  D. mov al,[dx]</p>
<ol start="5">
<li>下列寻址方式属于基址变址寻址的是（  ）。</li>
</ol>
<p>A. [di]  B. [bx+idata]  C. [bx+di]  D. [bp+di+idata]</p>
<ol start="6">
<li>“mov word ptr [bx+si],1”采用的寻址方式为（  ）。</li>
</ol>
<p>A.寄存器间接寻址 B.寄存器相对寻址 C.基址变址寻址     D.相对基址变址寻址</p>
<ol start="7">
<li>用div指令进行除法运算，除数为16位时，余数存放在（  ）中。</li>
</ol>
<p>A.AX   B.AH  C.AL   D.DX</p>
<ol start="8">
<li>若AX&#x3D;1000H，CL&#x3D;90H，则执行指令DIV CL之后，AX&#x3D;（  ）。</li>
</ol>
<p>A.401CH    B.001CH   C.0040H   D.1C40H</p>
<ol start="9">
<li>以下关于8086CPU的div指令的说法，错误的是（  ）。</li>
</ol>
<p>A.被除数可以放在寄存器中，也可以放在内存单元中。</p>
<p>B.若结果的商大于al或ax所能存储的最大值，将引发CPU内部的除法溢出错误。</p>
<p>C.可以重写0号中断处理程序，使得程序可以处理除法溢出的情况。</p>
<p>D.可使用div指令编写一个计算32位被除数&#x2F;8位除数的子程序。</p>
<ol start="10">
<li>执行以下指令后，AX的值是（  ）。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov al,96h  </span><br><span class="line"></span><br><span class="line">mov bl,12h</span><br><span class="line"></span><br><span class="line">mul bl</span><br></pre></td></tr></table></figure>

<p>A. 1152h 　　　　  B. 0a8ch</p>
<p>C. 0a82h 　　　   D. 0f88ch</p>
<ol start="11">
<li>以下指令执行后，AX的值是多少？（  ）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ah,1</span><br><span class="line">mov al,10h</span><br><span class="line">mov bl,2</span><br><span class="line">mul bl</span><br></pre></td></tr></table></figure>

<p>  A.0220H      B.2000H      C.0020H       D.0120H</p>
<ol start="12">
<li>下列指令中（  ）可以实现，将AX寄存器中的最低3位清0</li>
</ol>
<p>A、 OR  AX,0FFF8H</p>
<p>B、 AND AX,0FFF8H</p>
<p>C、 AND AX,0FFF7H</p>
<p>D、 AND AX,0FFFBH</p>
<ol start="13">
<li>下列指令中（  ）可以实现，将AX寄存器中的D3和D7位置1</li>
</ol>
<p>A、 XOR  AX,08H</p>
<p>B、 OR AX,08H</p>
<p>C、 OR AX,88H</p>
<p>D、 XOR AX,88H</p>
<ol start="14">
<li>下列指令中（  ）可以实现，将AX寄存器中的最高3位取反</li>
</ol>
<p>A、 NOT AX</p>
<p>B、 AND AX,1FFFH</p>
<p>C、 XOR  AX,0E000H</p>
<p>D、 OR  AX,0E000H</p>
<ol start="15">
<li>数据段中有如下定义</li>
</ol>
<p>  X1 DB 1,2,3,4,5,6,7,8</p>
<p>  X2  DW  1,2,3,4,5,6,7,8</p>
<p>以下指令中错误的是（   ）</p>
<p>A、 MOV   X1,100</p>
<p>B、 MOV  AX,X1</p>
<p>C、 MOV AX,X2</p>
<p>D、 MOV X2,100</p>
<ol start="16">
<li>数据段中有如下定义</li>
</ol>
<p>  X1 DB 1,2,3,4,5,6,7,8</p>
<p>  X2  DW 1,2,3,4,5,6,7,8</p>
<p>以下指令中正确的是（   ）</p>
<p>A、 MOV   X1,1000</p>
<p>B、 MOV  AX,X1</p>
<p>C、 MOV AH,X2</p>
<p>D、 MOV X2,1000</p>
<ol start="17">
<li>数据段中有如下定义</li>
</ol>
<p>  X1 DB 1,2,3,4,5,6,7,8,9,10</p>
<p>  X2 DW 100</p>
<p>执行完下面的程序段之后，DX的值是（   ）。</p>
<p>   MOV  CX,10</p>
<p>   MOV  DX,X2</p>
<p>S:  MOV  BX,CX</p>
<p>   MOV  AL,X1[BX]</p>
<p>   MOV  AH,0</p>
<p>   ADD  DX,AX</p>
<p>   DEC  CX</p>
<p>   LOOP  S</p>
<p>A、 124      B、 224      C、 155      D、 255</p>
<ol start="18">
<li>下列指令序列不能够实现把内存地址0:202h中的字节数据送入al功能的是______•</li>
</ol>
<p>A、 mov ax,0</p>
<p>mov ds,ax</p>
<p>mov bx,202h</p>
<p>mov al,[bx]</p>
<p>B、 mov ax,0</p>
<p>mov ds,ax</p>
<p>mov bp,202h</p>
<p>mov al,[bp]</p>
<p>C、 mov ax,0</p>
<p>mov ds,ax</p>
<p>mov bx,200h</p>
<p>mov al,[bx+2]</p>
<p>D、 mov ax,0</p>
<p>mov ds,ax</p>
<p>mov bp,200h</p>
<p>mov al,ds:[bp+2]</p>
<ol start="19">
<li>下列指令中，正确的是（ ）</li>
</ol>
<p>A、 MOV AX,[BX+BP]          B、MOV AX,[BX+SI]</p>
<p>C、 MOV  AL,[SI+DI]      D、 MOV  AL,[SI+DX]</p>
<ol start="20">
<li>下列指令中，错误的是（ ）</li>
</ol>
<p>A、 MOV AX,[BX+SI]      B、 MOV AX,[BX+DI]</p>
<p>C、 MOV  AL,[SI+DI]      D、 MOV  AL,[SI+BP]</p>
<ol start="21">
<li>下列指令中，正确的是（  ）</li>
</ol>
<p>A、 MOV DS:[BP+BX],AH       B、 ADD  [BX],100</p>
<p>C、 MOV  [SI],AL         D、 MOV  [SI],100</p>
<ol start="22">
<li>下列指令中，错误的是（  ）</li>
</ol>
<p>A、 MOV DS:[BP+SI],AH        B、ADD  WORD PTR [BX],100</p>
<p>C、 MOV  [SI],AL              D、 MOV  [SI],100</p>
<ol start="23">
<li>下列指令中，错误的是（  ）</li>
</ol>
<p>A.MOV DS:[BP+SI],AH          B.ADD  WORD PTR [SI],100</p>
<p>C.MOV  [SI],AL                 D.MOV  [SI],[DI]</p>
<ol start="24">
<li>下列哪个程序段可以实现将987*6 ？ （  ）</li>
</ol>
<p>A、 MOV  AX,987</p>
<p>MOV BX,6</p>
<p>MUL  AX,BX</p>
<p>B、 MOV  AX,987</p>
<p>MOV BX,6</p>
<p>MUL  BX</p>
<p>C、 MOV  AX,987</p>
<p>MOV BL,6</p>
<p>MUL  BL</p>
<p>D、 MOV  AL,6</p>
<p>MOV BX,987</p>
<p>MUL  BX</p>
<ol start="25">
<li>下列哪个程序段可以实现将987&#x2F;30 ？ （  ）</li>
</ol>
<p>A、 MOV  AX,987</p>
<p>MOV BX,30</p>
<p>DIV  BX</p>
<p>B、 MOV  DX,987</p>
<p>MOV BL,30</p>
<p>DIV  BL</p>
<p>C、 MOV  AX,987</p>
<p>MOV BL,30</p>
<p>DIV  BL</p>
<p>D、 以上选项都不对</p>
<ol start="26">
<li>执行下列程序段</li>
</ol>
<p>MOV  AX,87</p>
<p>MOV BX,6</p>
<p>MUL  BX</p>
<p> 去 （  ）寄存器查看结果</p>
<p>A、 AX       B、BX        C、DX        D、 DX存放结果高16位，AX存放结果低16位</p>
<ol start="27">
<li>执行下列程序段</li>
</ol>
<p>MOV  AX,87</p>
<p>MOV BL,6</p>
<p>MUL  BL</p>
<p> 去 （  ）寄存器查看结果</p>
<p>A、 AX</p>
<p>B、 BX</p>
<p>C、 AL</p>
<p>D、 DX存放结果高16位，AX存放结果低16位</p>
<ol start="28">
<li>数据段中有如下定义：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> DATA1 DB  1,2,3,4</span><br><span class="line">DB  5,6,7,8</span><br><span class="line"></span><br><span class="line"> DB  9,10,11,12</span><br><span class="line"></span><br><span class="line"> DB  1,2,3,4</span><br></pre></td></tr></table></figure>

<p>执行下列程序段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   MOV  BX,0</span><br><span class="line"></span><br><span class="line">   MOV SI,0</span><br><span class="line"></span><br><span class="line">   MOV CX,4</span><br><span class="line"></span><br><span class="line">   MOV AL,0</span><br><span class="line"></span><br><span class="line">S:  ADD  AL,DATA1[BX][SI]</span><br><span class="line"></span><br><span class="line">   INC SI</span><br><span class="line"></span><br><span class="line">   ADD  BX,4</span><br><span class="line"></span><br><span class="line">   LOOP  S</span><br></pre></td></tr></table></figure>

<p> AL寄存器的结果是（   ）</p>
<p>A、 10       B、 16       C、 24       D、 22</p>
<ol start="29">
<li>数据段中有如下定义：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> DATA1 DB  1,2,3,4</span><br><span class="line">DB  5,6,7,8</span><br><span class="line"></span><br><span class="line">DB  9,10,11,12</span><br><span class="line"></span><br><span class="line">DB  1,2,3,4</span><br></pre></td></tr></table></figure>

<p>执行下列程序段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MOV  BX,0</span><br><span class="line">MOV SI,0</span><br><span class="line">MOV CX,4</span><br><span class="line">MOV AL,0</span><br><span class="line">S:  ADD  AL,DATA1[BX][SI]</span><br><span class="line">INC SI</span><br><span class="line">INC BX</span><br><span class="line">LOOP  S</span><br></pre></td></tr></table></figure>

<p> AL寄存器的结果是（   ）</p>
<p>A、 10       B、 16       C、 24       D、 22</p>
<ol start="30">
<li>数据段中有如下定义：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> DATA1 DB  1,2,3,4</span><br><span class="line">DB  5,6,7,8</span><br><span class="line"></span><br><span class="line">DB  9,10,11,12</span><br><span class="line"></span><br><span class="line">DB  1,2,3,4</span><br></pre></td></tr></table></figure>

<p>执行下列程序段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   MOV  BX,0</span><br><span class="line"></span><br><span class="line">   MOV SI,0</span><br><span class="line"></span><br><span class="line">   MOV CX,4</span><br><span class="line"></span><br><span class="line">   MOV AL,0</span><br><span class="line"></span><br><span class="line">S:  ADD  AL,DATA1[BX+SI]</span><br><span class="line"></span><br><span class="line">   ADD  AL,DATA1[BX+4+SI]</span><br><span class="line"></span><br><span class="line">   INC SI</span><br><span class="line">   LOOP  S</span><br></pre></td></tr></table></figure>

<p> AL寄存器的结果是（   ）</p>
<p>A、 10       B、 16       C、 52       D、 36</p>
<ol start="31">
<li>有如下定义，说法正确的是（  ）。</li>
</ol>
<p> X DW  5  DUP (1,2,3)</p>
<p>A、 总共定义了15个字节          B、 总共定义了3个字节</p>
<p>C、 总共定义了5个字节       D、 总共定义了30个字节</p>
<ol start="32">
<li>有如下定义，说法正确的是（  ）。</li>
</ol>
<p> X DB  3  DUP (1,2 DUP(3))</p>
<p>A、 相当于  X  DB  1，2，3</p>
<p>B、 相当于   X  DB  1，2，3，1，2，3，1，2，3</p>
<p>C、 相当于  X  DB  1，3，3，1，3，3，1，3，3</p>
<p>D、相当于  X  DB  1，2，2，1，2，2，1，2，2</p>
<ol start="33">
<li>有如下定义，说法正确的是（  ）。</li>
</ol>
<p> X DW  5  DUP (1,3 dup（2）)</p>
<p>A、 总共定义了10个字节          B、 总共定义了20个字节</p>
<p>C、 总共定义了30个字节           D、 总共定义了40个字节</p>
<h4 id="答案与解析-3"><a href="#答案与解析-3" class="headerlink" title="答案与解析"></a>答案与解析</h4><ol>
<li>A. [bx+si+idata]</li>
<li>D. si，di，bp，bx</li>
<li>D. 80,dd占4个字节，一共有20个数字，因此4*20&#x3D;80</li>
<li>D. dx不作为寻址的寄存器</li>
<li>C. [bp+di]</li>
<li>C.基址变址寻址</li>
<li>D.DX,顺带一提，商存在AX寄存器</li>
<li>B.001CH</li>
<li>A.被除数只能放寄存器，除数可以放reg和内存单元，具体细节可以看书上8.7节</li>
<li>这题选B，0a8ch，十六进制乘法不懂可以自己上网搜索</li>
<li>D.0120H</li>
<li>B、 AND AX,0FFF8H</li>
<li>C、 OR AX,88H</li>
<li>C、 XOR AX,0E000H,将指定位取反优先考虑异或，这是个做题技巧捏</li>
<li>B、 X2是一个8位字单元，不能直接送到16位的AX寄存器</li>
<li>C</li>
<li>B、 224</li>
<li>B、 bp寄存器对应的段寄存器是ss，只设置ds是没用的</li>
<li>B、MOV AX,[BX+SI]</li>
<li>C、 MOV AL,[SI+DI]</li>
<li>B、 ADD [BX],100</li>
<li>D、 MOV [SI],100</li>
<li>D.MOV [SI],[DI].si和di不能同时出现，bp和bx也是</li>
<li>B、</li>
<li>C、 MOV AX,987 MOV BL,30 DIV BL</li>
<li>D、 DX存放结果高16位，AX存放结果低16位</li>
<li>D、 AX</li>
<li>C、 24</li>
<li>B、 16</li>
<li>D、 36</li>
<li>D、 总共定义了30个字节</li>
<li>C、 相当于 X DB 1，3，3，1，3，3，1，3，3</li>
<li>D、 总共定义了40个字节</li>
</ol>
<h3 id="第9-10章"><a href="#第9-10章" class="headerlink" title="第9-10章"></a>第9-10章</h3><ol>
<li><p>CPU在执行“call标号” 时，相当于执行（  ）。</p>
<p>A.   push IP ； jmp far ptr 标号</p>
<p>B.   push  CS ； push IP ； jmp far ptr 标号</p>
<p>C. push IP ； jmp near ptr 标号</p>
<p>D. push  CS ； push IP ； jmp near ptr 标号</p>
</li>
<li><p>使用call和ret指令，我们可以实现汇编语言编程中的模块化设计。以下描述中错误的是（  ）。</p>
<p>A. 可以用call和ret指令实现多个子程序。</p>
<p>B. 可以通过多个相互联系、功能独立的子程序来解决一个复杂的问题。</p>
<p>C. 对于通用的子程序，最好加上详细的注释。</p>
<p>D. 用汇编语言进行程序设计，子程序一定要用call和ret来实现。</p>
</li>
<li><p>以下程序执行后，AX的值为（  ）。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,4</span><br><span class="line">CALL S</span><br><span class="line"></span><br><span class="line">NOP</span><br><span class="line">S：</span><br><span class="line"> MOV AX,OFFSET S</span><br><span class="line"></span><br><span class="line">MOV BP,SP</span><br><span class="line"></span><br><span class="line">SUB AX,[BP]</span><br></pre></td></tr></table></figure>

<p>A.0    B.1   C.2    D.3</p>
<ol start="4">
<li>对于根据位移进行跳转的jmp指令，跳转的位移是在什么时候计算的？（ ）</li>
</ol>
<p>A. 编译  B. 连接  C. 运行  D. 编译或运行</p>
<ol start="5">
<li>可修改cs和ip的指令是（  ）。</li>
</ol>
<p>A. jmp ax  B. jmp far ptr s  C. loop  D. ret</p>
<ol start="6">
<li>“jmp word ptr [bx]”进行的是（  ）。</li>
</ol>
<p>A.   段内近转移   B.段间近转移 C.段内短转移 D.段间短转移</p>
<ol start="7">
<li>“jmp word ptr [bx]”修改寄存器是（  ）。</li>
</ol>
<p>A.IP B. BP     C.CS D.CS和IP</p>
<ol start="8">
<li>哪个指令的跳转范围可以与其它三个不同？（  ）</li>
</ol>
<p>A.jmp   B.jcxz   C.loop   D.je</p>
<ol start="9">
<li>下列说法正确的是（  ）。</li>
</ol>
<p>A.   iret指令可以描述为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">popf</span><br><span class="line">pop cs</span><br><span class="line">pop ip</span><br></pre></td></tr></table></figure>

<p>B.   mov al,1</p>
<p>add al,0ffh</p>
<p>上面两条指令执行后，(AX)&#x3D;0</p>
<p>C.   用debug进行调试时，用p命令可以一次执行多条汇编指令</p>
<p>D.   call指令不能通过位移进行跳转</p>
<ol start="10">
<li><p>关于loop指令，错误的说法是（  ）。</p>
<p>A.loop指令的跳转范围是-128~127</p>
<p>B.CX&#x3D;10时，执行loop指令，IP的值一定减小</p>
<p>C.CX&#x3D;0时，执行loop指令后，CX&#x3D;0ffffh</p>
<p>D.CX&#x3D;1时，执行loop指令，IP的值不变</p>
</li>
<li><p>假设sp&#x3D;0010h，则执行哪条指令，sp的值会减小？（  ）</p>
</li>
</ol>
<p>A.IRET   B.JMP 标号   C.RETF   D.CALL 标号</p>
<ol start="12">
<li>在debug中，用“d 1000：0”查看内存，显示如下.</li>
</ol>
<p>1000：0000  69 76 65 20 25 63 20 61-6E 64 20 70 72 65 73 73</p>
<p>1000：0010  20 3C 45 4E 54 45 52 3E-0A 00 6B 00 41 62 6F 75</p>
<p>1000：0020  74 20 74 6F 20 67 65 6E-65 72 61 74 65 20 2E 45</p>
<p>接着，即写且执行以下指令：</p>
<p>mov ax,1000</p>
<p>mov ds,ax</p>
<p>jmp DWORD PTR [2]</p>
<p>之后，cs：ip的值依次是（  ）。</p>
<p>A.6325：2065  B.6520：2563  C.2065：7669    D.6520：2567</p>
<ol start="13">
<li>关于转移指令，错误的说法是（  ）。</li>
</ol>
<p>A.进行段内短转移时，jmp指令对应的机器码中没有转移的目的地址。</p>
<p>B.进行段间转移时，jmp指令对应的机器码中有转移的目的地址。</p>
<p>C.进行段内短转移时，IP的修改范围是0~255。</p>
<p>D.loop指令也是转移指令。</p>
<ol start="14">
<li><p>读取，执行哪条指令CPU会修改两次IP？（  ）</p>
<p>A.push   B.pushf   C.ret    D.mov</p>
</li>
<li><p>在debug中用t命令执行下列指令，可观察到的现象是（  ）。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">内存地址     汇编指令</span><br><span class="line"> 076e：0      mov ax,5</span><br><span class="line"></span><br><span class="line"> 076e：3      call ax</span><br><span class="line"></span><br><span class="line"> 076e：5      inc ax</span><br><span class="line"></span><br><span class="line"> 076e：6      mov bp,sp</span><br><span class="line"></span><br><span class="line"> 076e：8      jmp word ptr [bp]</span><br></pre></td></tr></table></figure>

<p> A.循环执行mov ax,5   和call ax</p>
<p>B.循环执行call ax到jmp word ptr [bp]</p>
<p>C.循环执行inc ax到jmp word ptr [bp]</p>
<p>D.ss：bp指向处的数据未知，因而跳转到未知内存处，结果不可预测</p>
<ol start="16">
<li><p>用一条指令补全程序，使这个程序可以返回。（  ）<br>assume cs：code<br>data segment<br>dd 4 dup (0)<br>data ends<br>code segment<br>s：<br>mov ax,4c00h<br>int 21h<br>code ends</p>
<p>assume cs：a<br>a segment<br>start：<br>a ends<br>end start</p>
</li>
</ol>
<p>A.jmp s    B.loop s   C.jmp far ptr s    D.jmp near ptr s</p>
<ol start="17">
<li>读取执行下面的指令之后，CPU总共修改了几次IP的值？（  ）</li>
</ol>
<p>SUB AX,AX</p>
<p>RETF</p>
<p>A.1   B.2   C.3    D.4</p>
<ol start="18">
<li>8086CPU读取、执行指令的过程是（  ）。</li>
</ol>
<p>①从CS：IP指向的内存空间读取指令，将指令放入指令缓冲器</p>
<p>②执行指令，转到步骤①</p>
<p>③IP指向下一条指令</p>
<p>A.① ②</p>
<p>B.① ③ ②</p>
<p>C.若指令是转移指令，过程为① ③ ②，不是则过程为① ②</p>
<p>D.若指令是转移指令，过程为① ②，不是则过程为① ③ ②</p>
<ol start="19">
<li>有以下定义</li>
</ol>
<p>DATA SEGMENT</p>
<p> X1 DB 5 DUP (1，2，3)</p>
<p> X2 DW 1</p>
<p> X3 DW 1000H</p>
<p>DATA ENDS</p>
<p>执行下面的程序段后，CX的值为（  ）</p>
<p>  MOV  AX,DATA</p>
<p>  MOV  DS,AX</p>
<p>  MOV  CX,OFFSET X3</p>
<p>A、 15</p>
<p>B、 16</p>
<p>C、 17</p>
<p>D、 18</p>
<ol start="20">
<li>用Debug查看内存，结果如下：</li>
</ol>
<p>2000:1000 04 05 60 BE 00 06 00 00 00 ……</p>
<p>则此时，CPU执行指令：</p>
<p>mov ax,2000H</p>
<p>mov es,ax</p>
<p>jmp dword ptr es:[1002H]</p>
<p>后，说法正确的是（   ）</p>
<p>A、 (CS)&#x3D;2000H，(IP)&#x3D;1002h</p>
<p>B、 (CS)&#x3D;BE60H，(IP)&#x3D;0600H</p>
<p>C、 (CS)&#x3D;60BEH，(IP)&#x3D;0006H</p>
<p>D、 (CS)&#x3D;0600H，(IP)&#x3D;BE60H</p>
<ol start="21">
<li>有以下定义</li>
</ol>
<p>DATA SEGMENT</p>
<p> X1 DB 5 DUP (1，2，3)</p>
<p> X2 DW 1</p>
<p> X3 DW 1000H</p>
<p>DATA ENDS</p>
<p>执行下面的程序段后，CX的值为（  ）</p>
<p>  MOV  AX,DATA</p>
<p>  MOV  DS,AX</p>
<p>  MOV  BX,OFFSET X3</p>
<p>  MOV  CX,[BX]</p>
<p>A、 18</p>
<p>B、 17</p>
<p>C、 1</p>
<p>D、 1000H</p>
<ol start="22">
<li>关于指令 JMP SHORT 标号，说法正确的是</li>
</ol>
<p>A、 执行该指令，修改CS和IP一次</p>
<p>B、 执行该指令，修改IP一次</p>
<p>C、 执行该指令，修改IP两次</p>
<p>D、 执行该指令，修改IP三次</p>
<ol start="23">
<li>关于指令 JMP SHORT 标号，说法正确的是</li>
</ol>
<p>A、 执行该指令，（IP）&#x3D;（IP）+8位位移量</p>
<p>B、 执行该指令，（IP）&#x3D;（IP）+16位位移量</p>
<p>C、 执行该指令，（IP）&#x3D;（IP）+标号所在段中的偏移地址</p>
<p>D、 执行该指令，（IP）&#x3D;标号所在段中的偏移地址</p>
<ol start="24">
<li>关于指令 JMP NEAR PTR 标号，说法正确的是</li>
</ol>
<p>A、 执行该指令，（IP）&#x3D;（IP）+8位位移量</p>
<p>B、 执行该指令，（IP）&#x3D;（IP）+16位位移量</p>
<p>C、 执行该指令，（IP）&#x3D;（IP）+标号所在段中的偏移地址</p>
<p>D、 执行该指令，（IP）&#x3D;标号所在段中的偏移地址</p>
<ol start="25">
<li>关于指令 JMP FAR PTR 标号，说法正确的是</li>
</ol>
<p>A、 执行该指令，（IP）&#x3D;（IP）+8位位移量</p>
<p>B、 执行该指令，（IP）&#x3D;（IP）+16位位移量</p>
<p>C、 执行该指令，（IP）&#x3D;（IP）+标号所在段中的偏移地址</p>
<p>D、 执行该指令，（IP）&#x3D;标号所在段中的偏移地址</p>
<ol start="26">
<li>下列指令中，没有修改CS的是（   ）</li>
</ol>
<p>A、 JMP  AX</p>
<p>B、 JMP  FAR PTR  S1</p>
<p>C、 JMP DWORD PTR  DS:[0]</p>
<p>D、 JMP DWORD PTR [BX]</p>
<ol start="27">
<li>下列指令中，同时修改CS和IP的是（   ）</li>
</ol>
<p>A、 JMP  AX</p>
<p>B、 JMP  NEAR PTR  S1</p>
<p>C、 JMP WORD PTR  DS:[0]</p>
<p>D、 JMP DWORD PTR [BX]</p>
<h4 id="答案与解析-4"><a href="#答案与解析-4" class="headerlink" title="答案与解析"></a>答案与解析</h4><ol>
<li>C.call只改变IP的值</li>
<li>D. 用汇编语言进行程序设计，子程序一定要用call和ret来实现。这个不一定，你自己用call本质上就是使用了jmp和push指令，你直接用jmp，push和call是在功能上是等价的</li>
<li>A. 0</li>
<li>A. 编译</li>
<li>B. jmp far ptr s</li>
<li>A. 段内近转移</li>
<li>A.段内转移只修改IP</li>
<li>A. jmp.这里你必须知道一个信息，所有有条件转移的指令都是短转移，jmp是无条件的，因此只有他最与众不同</li>
<li>A. iret指令可以描述为：popf；pop cs；pop ip</li>
<li>C. CX&#x3D;0时，执行loop指令后，CX&#x3D;0ffffh</li>
<li>D. CALL 标号</li>
<li>A. 6325:2065</li>
<li>C. 进行段内短转移时，IP的修改范围是0~255</li>
<li>C. ret</li>
<li>D. ss：bp指向处的数据未知，因而跳转到未知内存处，结果不可预测</li>
<li>A. jmp s</li>
<li>C. 3次.Sub修改一次，RETF修改两次</li>
<li>B. ① ③ ②</li>
<li>B. 16</li>
<li>D. (CS)&#x3D;BE60H，(IP)&#x3D;0600H</li>
<li>D.1000H</li>
<li>B. 执行该指令，修改IP一次1</li>
<li>A. 执行该指令，（IP）&#x3D;（IP）+8位位移量</li>
<li>B. 执行该指令，（IP）&#x3D;（IP）+16位位移量</li>
<li>D. 执行该指令，（IP）&#x3D;标号所在段中的偏移地址</li>
<li>A. JMP AX</li>
<li>D. JMP DWORD PTR [BX]</li>
</ol>
<h3 id="第11章"><a href="#第11章" class="headerlink" title="第11章"></a>第11章</h3><ol>
<li><p>以下指令执行后，of和cf的值是（  ）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">push ax</span><br><span class="line">popf</span><br><span class="line">mov ax,0ffffh</span><br><span class="line">inc ax </span><br></pre></td></tr></table></figure>

<p>A. of&#x3D;0，cf&#x3D;0</p>
<p>B. of&#x3D;1，cf&#x3D;0</p>
<p>C. of&#x3D;0，cf&#x3D;1</p>
<p>D. of&#x3D;1，cf&#x3D;1</p>
</li>
<li><p>以下指令执行后，sf、cf、zf、of的值分别是（  ）。<br><code>mov ax,0ea04h  sub ax,4ae0h  </code></p>
<p>A. 0，1，0，1</p>
<p>B. 1，1，0，0</p>
<p>C. 1，0，0，0</p>
<p>D. 1，0，1，0</p>
</li>
<li><p>可以改变标志寄存器的值的指令是（  ）。<br>A.PUSHF   B.MOV AX,AX     C.SHL AX,CL   D.JCXZ</p>
</li>
<li><p>可改变SF和ZF的值的指令是（  ）。<br>A.JE NEXT   B.IN AL,20H   C.PUAH AX   D.SHL AX,1</p>
</li>
<li><p>不会影响标志寄存器的值的指令是（  ）。<br>A.adc ax,bx   B.cmp cx,ax   C.inc ax    D.jmp word ptr [bx]</p>
</li>
<li><p>可使if&#x3D;1的指令是（  ）。</p>
<p>A.sti   B.cld   C.std   D.shr</p>
</li>
<li><pre><code class="assembly">mov al,62h
add al,63h
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   这两条指令执行后，cf\of的值是（  ）。</span><br><span class="line"></span><br><span class="line">   A. cf=0，of=0 B. cf=0，of=1  C. cf=1，of=0  D. cf=1，of=1</span><br><span class="line">8. 下面对标志位的描述，正确的是（  ）。</span><br><span class="line"></span><br><span class="line">   A. 可以用栈指令改变标志位的值</span><br><span class="line"></span><br><span class="line">   B. Cmp、pushf指令都可能会对标志位的值产生影响</span><br><span class="line"></span><br><span class="line">   C. 可以通过判断cmp指令执行后的sf位是否为1知道两个数的大小</span><br><span class="line"></span><br><span class="line">   D. 传送指令.移位指令对标志位的值无影响</span><br><span class="line">9. 执行JNB指令时，（  ），则进行跳转。</span><br><span class="line"></span><br><span class="line">   A.CF=1且ZF=1         B.CF=0或ZF=1    C.CF=0或ZF=0 D.CF=0</span><br><span class="line">10. 下面的程序执行后，PF、SF、CF、OF的值分别为（  ）。</span><br><span class="line"></span><br><span class="line">    MOV AX,0FF80H</span><br><span class="line"></span><br><span class="line">    ADD AL,0F0H</span><br><span class="line"></span><br><span class="line">    A.PF=1 SF=1 CF=1 OF=1      B.PF=0 SF=1 CF=1 OF=1</span><br><span class="line"></span><br><span class="line">    C.PF=0 SF=0 CF=1 OF=1      D.PF=1 SF=0 CF=0 OF=0</span><br><span class="line">11. 下面的程序执行后，PF、SF、CF、OF、ZF的值分别为（  ）。</span><br><span class="line"></span><br><span class="line">    MOV AX,0FF80H</span><br><span class="line"></span><br><span class="line">    XOR AX,AX</span><br><span class="line"></span><br><span class="line">    A.PF=1 SF=1 CF=1 OF=1 ZF=0      B.PF=0 SF=1 CF=1 OF=1 ZF=0</span><br><span class="line"></span><br><span class="line">    C.PF=0 SF=0 CF=1 OF=1 ZF=1      D.PF=1 SF=0 CF=0 OF=0 ZF=1</span><br><span class="line">12. 下列与标志寄存器相关的说法，错误的是（  ）。</span><br><span class="line"></span><br><span class="line">    A.标志寄存器可以通过栈指令访问</span><br><span class="line"></span><br><span class="line">    B.当al=0ffh，执行“inc al”，将影响cf的值</span><br><span class="line"></span><br><span class="line">    C.算数运算指令不会影响df标志位</span><br><span class="line"></span><br><span class="line">    D.根据无符号数的比较结果进行转移的条件转移指令，检测的是zf.cf的值</span><br><span class="line">13. 对于标志寄存器相关位的描述，错误的是（ ）。</span><br><span class="line"></span><br><span class="line">    A.   mov al,1</span><br><span class="line"></span><br><span class="line">    add al,127</span><br><span class="line"></span><br><span class="line">    结果为128（80H）,SF为1，超出了-128~127的范围，所以OF为1，这两条指令执行后，OF=1，发生溢出；虽然逻辑结果为正，但SF却为1</span><br><span class="line"></span><br><span class="line">    B.   mov al,1</span><br><span class="line"></span><br><span class="line">        add al,0ffh</span><br><span class="line"></span><br><span class="line">    结果为100h，保留00H,CF=1，正数1和负数-1相加，不会溢出，OF=0。这两条指令执行后，OF=0，CF=1</span><br><span class="line"></span><br><span class="line">    C.“inc ax”不影响标志寄存器的CF位</span><br><span class="line"></span><br><span class="line">    D.   S：mov ax,8f00h</span><br><span class="line"></span><br><span class="line">        cmp ax,5 ；</span><br><span class="line"></span><br><span class="line">    标志寄存器不改变，保留原值，执行中断子程序，执行中间可能会影响标志寄存器这段程序执行过程中，SF一直为1</span><br><span class="line">14. 下列指令，一定不会使标志寄存器发生变化的是（ ）。</span><br><span class="line"></span><br><span class="line">    A.int 21h      B.jmp ax  C.cmp ax,bx  D.sub ax,ax</span><br><span class="line">15. 如果AL=75H，则执行ADD AL,0F0H之后，OF、CF的值是（  ）。</span><br><span class="line"></span><br><span class="line">    A.OF=1，CF=0   B.OF=0，CF=0  C.OF=0，CF=1    D.OF=1，CF=1</span><br><span class="line">16. 以下哪个选项中的指令执行后，zf=1，pf=1？（  ）</span><br><span class="line"></span><br><span class="line">    A.mov ax,1   B.mov ax,1   C.mov ax,1    D.mov ax,1</span><br><span class="line"></span><br><span class="line">    add ax,2    and ax,0    sub ax,2     or ax,0</span><br><span class="line">17. 以下哪个选项中的指令执行后，cf=1,of=1？（  ）</span><br><span class="line"></span><br><span class="line">    A.mov al,98      add al,99</span><br><span class="line">    B.mov al,0f0H  add al,88H</span><br><span class="line">    C.mov al,0f0H  add al,78H</span><br><span class="line">    D.mov al,68H   add al,1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">18. 关于串传送指令，错误的说法是（  ）。</span><br><span class="line"></span><br><span class="line">    A.只用一条movsb指令，即可以将一个内存单元里的数据传送到另一个内存单元</span><br><span class="line"></span><br><span class="line">    B.movsb指令执行后，SI与DI的值可能会增加，也可能会减小</span><br><span class="line"></span><br><span class="line">    C.传送可以以字节为单位进行，也可以以字为单位进行</span><br><span class="line"></span><br><span class="line">    D.如果在执行“movsb”之前，CX的值是10，“movsb”将重复执行10次</span><br><span class="line">19. 关于串传送指令，正确的说法是（  ）。</span><br><span class="line"></span><br><span class="line">    A. movsb指令，将一个ds:di指向内存单元里的字节传送到es:si内存单元中</span><br><span class="line"></span><br><span class="line">    B. 如果DF=1，则movsb指令执行后，SI会增加1</span><br><span class="line"></span><br><span class="line">    C.传送可以只能以字节为单位进行</span><br><span class="line"></span><br><span class="line">    D. rep和 movsb配合使用，可以传送一批数据。</span><br><span class="line">20. 对于8086CPU的标志寄存器，下列说法错误的是（  ）。</span><br><span class="line"></span><br><span class="line">    A.标志寄存器是16位的</span><br><span class="line"></span><br><span class="line">    B.无法通过一条汇编指令将标志寄存器的所有位都更新</span><br><span class="line"></span><br><span class="line">    C.这个寄存器中的有些位没有任何含义</span><br><span class="line"></span><br><span class="line">    D.cmp指令能够改变标志寄存器的值</span><br><span class="line"></span><br><span class="line">#### 答案与解析</span><br><span class="line"></span><br><span class="line">1. D. of=1，cf=1</span><br><span class="line">2. C. 1，0，0，0</span><br><span class="line">3. A.PUSHF</span><br><span class="line">4. D.SHL AX,1</span><br><span class="line">5. D.jmp word ptr [bx]1</span><br><span class="line">6. A.sti</span><br><span class="line">7. C. cf=1，of=0</span><br><span class="line">8. A. 可以用栈指令改变标志位的值</span><br><span class="line">9. B.JNB大于或等于转移.</span><br><span class="line">10. B.PF=0 SF=1 CF=1 OF=1</span><br><span class="line">11. D.PF=1 SF=0 CF=0 OF=0 ZF=1</span><br><span class="line">12. B.当al=0ffh，执行“inc al”，将影响cf的值</span><br><span class="line">13. D</span><br><span class="line">14. B.jmp ax</span><br><span class="line">15. D.OF=1，CF=1</span><br><span class="line">16. B.mov ax,1 and ax,0</span><br><span class="line">17. B.mov al,0f0H add al,88H</span><br><span class="line">18. A.只用一条movsb指令，即可以将一个内存单元里的数据传送到另一个内存单元</span><br><span class="line">19. D. rep和 movsb配合使用，可以传送一批数据。</span><br><span class="line">20. B.无法通过一条汇编指令将标志寄存器的所有位都更新.这个自己看书，在第11章有</span><br><span class="line"></span><br><span class="line">### 第12章及之后</span><br><span class="line"></span><br><span class="line">1. 中断向量表中存放的是（  ）。</span><br><span class="line"></span><br><span class="line">A. 中断类型码      B. 中断处理程序的入口地址</span><br><span class="line"></span><br><span class="line">C. 中断处理程序     D. 断点地址</span><br><span class="line"></span><br><span class="line">2. 中断向量占（  ）字节。</span><br><span class="line"></span><br><span class="line">A. 1      B. 2        C. 3     D. 4</span><br><span class="line"></span><br><span class="line">3. 使用call和ret指令，我们可以实现汇编语言编程中的模块化设计。以下描述中错误的是（  ）。</span><br><span class="line"></span><br><span class="line">   A. 可以用call和ret指令实现多个子程序。</span><br><span class="line"></span><br><span class="line">   B. 可以通过多个相互联系.功能独立的子程序来解决一个复杂的问题。</span><br><span class="line"></span><br><span class="line">   C. 对于通用的子程序，最好加上详细的注释。</span><br><span class="line"></span><br><span class="line">   D. 用汇编语言进行程序设计，子程序一定要用call和ret来实现。</span><br><span class="line">4. 以下指令执行后，al和cf的值分别是（  ）。</span><br><span class="line"></span><br><span class="line">```assembly</span><br><span class="line">mov al,00000001B</span><br><span class="line">mov cx,109h</span><br><span class="line">shl al,cl</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p>A. 29 ，1   B. 29 ，0   C. 0，1   D. 0，0</p>
<ol start="5">
<li>已知（AX）&#x3D;2，则能实现（AX）&#x3D;（AX）*8的程序段是（  ）。</li>
</ol>
<p>A.SHL AX,3      B.SHR AX,3</p>
<p>C.MOV CL,3      D.MOV CL,3</p>
<p>SHL AX,CL       SHR AX,CL</p>
<ol start="6">
<li>关于shl与shr，正确的说法是（  ）。</li>
</ol>
<p>A.shl用0补充最高位。</p>
<p>B.shr将一个寄存器或内存单元中的数据向左移动。</p>
<p>C.移出的bit的值是0，shl与shr不影响CF。</p>
<p>D.shr用0补充最高位。</p>
<ol start="7">
<li>其逻辑不是实现 (ax)&#x3D;(ax)*10的程序段是（  ）。</li>
</ol>
<p>A. shl ax,1</p>
<p>mov bx,ax</p>
<p>mov cl,2</p>
<p>shl ax,cl</p>
<p>add ax,bx</p>
<p>B. mov bx,ax</p>
<p>shl ax,1</p>
<p>shl bx,1</p>
<p>shl bx,1</p>
<p>add ax,ax</p>
<p>add ax,bx</p>
<p>C. mov bx,ax</p>
<p>mov cl,3</p>
<p>shl ax,cl</p>
<p>shl bx,1</p>
<p>add ax,bx</p>
<p>D. mov cl,3</p>
<p>shl ax,cl</p>
<p>mov bx,ax</p>
<p>mov cl,2</p>
<p>shr bx,cl</p>
<p>add ax,bx</p>
<ol start="8">
<li>现在想要判断AL的值是否是某个正整数的2^n（n是正整数）次方，若al&#x3D;10000110b，那么至少需要移位几位，通过cf的值可判断出结果？（  ）</li>
</ol>
<p>A.1           B.2           C.3           D.4</p>
<ol start="9">
<li>中断向量表中存放的是（ ）。</li>
</ol>
<p>A.中断类型码  B.断点地址   C.中断处理程序  D.中断处理程序的入口地址</p>
<ol start="10">
<li>可以实现将ax的值增大2倍的是（  ）。</li>
</ol>
<p>A. mul 2   B. mul ax,2   C. shl ax,1  D. shr ax,1</p>
<ol start="11">
<li>对于8086CPU，正确的指令是（  ）。</li>
</ol>
<p>A. inc cx,1    B. shl ax,2   C. and [bp],al    D. mov [bx][bp],ax</p>
<ol start="12">
<li>对于在debug中使用t命令，正确的说法是（  ）。</li>
</ol>
<p>A.可触发单步中断   B.将执行完整个程序   C.只能执行一条指令</p>
<p>D.在依次执行完“mov ax,4c00h”、“int 21h”这两条指令后，程序返回</p>
<ol start="13">
<li>mov ax,4c00h</li>
</ol>
<p>int 21h</p>
<p>这段程序的作用是（ ）。</p>
<p>A.   调用21h号中断例程的4c00h号功能</p>
<p>B.   告诉编译器程序到此结束</p>
<p>C.   返回DOS</p>
<p>D.   前三个选项都不对</p>
<ol start="14">
<li><p>正确的说法是（ ）。</p>
<p>A.可用这段代码读取CMOS中的年份信息</p>
<p>mov al,9</p>
<p>in 70h,al</p>
<p>out al,71h</p>
<p>B.在移位指令中，可以用bl存储大于1的移位数</p>
<p>C.用shl指令对al进行移位，要注意对ah的值的影响;</p>
<p>D.十进制数码的ASCII码&#x3D;十进制数码的BCD码+30h ；</p>
<p>E.后面有“：”的地址标号能够写在所有段内</p>
<p>F.数据标号只能写在数据段内</p>
</li>
</ol>
<h4 id="答案与解析-5"><a href="#答案与解析-5" class="headerlink" title="答案与解析"></a>答案与解析</h4><ol>
<li>中断向量表中存放的是 <strong>中断处理程序的入口地址</strong>正确答案: <strong>B</strong></li>
<li>中断向量占 <strong>4</strong> 字节，正确答案: <strong>D</strong></li>
<li>错误的描述是 <strong>用汇编语言进行程序设计，子程序一定要用call和ret来实现</strong>。因为子程序也可以通过其他方式实现，例如使用跳转指令。正确答案: <strong>D</strong></li>
<li>执行后，<code>al</code>的值为 <strong>0</strong>，<code>cf</code>的值为 <strong>1</strong>。因为 <code>cl</code>的值为 <code>109h</code>，即 <code>1001001b</code>，表示左移 <code>1001001</code>位，这会将 <code>al</code>中的 <code>1</code>左移出去，导致 <code>al</code>变为 <code>0</code>，并且最后一位移入 <code>cf</code>。正确答案: <strong>C</strong></li>
<li>能实现 <code>(AX) = (AX) * 8</code> 的程序段是 <strong>SHL AX,3</strong>。正确答案: <strong>A</strong></li>
<li>关于 <code>shl</code>与 <code>shr</code>，正确的说法是 <strong>shr用0补充最高位</strong>。正确答案: <strong>D</strong></li>
<li>这道题的题目可能有点问题，<br>A等价于AX * 6<br>B等价于AX * 8<br>C等价于AX * 10<br>D等价于AX * 64</li>
<li>判断 <code>AL</code>的值是否是某个正整数的 <code>2^n</code>次方，若 <code>al=10000110b</code>，至少需要移位 <strong>4</strong> 位，通过 <code>cf</code>的值可判断出结果。正确答案: <strong>D</strong></li>
<li>中断向量表中存放的是 中断处理程序的入口地址。正确答案: <strong>D</strong></li>
<li>可以实现将 <code>ax</code>的值增大2倍的是 <strong>shl ax,1</strong>。正确答案: <strong>C</strong></li>
<li>对于8086CPU，正确的指令是 <strong>shl ax,2</strong>。正确答案: <strong>B</strong></li>
<li>这道题选<strong>A</strong>,t命令指的是单步中断，并不是执行一条指令</li>
<li>mov ax,4c00h int 21h&#96; 这段程序的作用是 <strong>返回DOS</strong>正确答案: <strong>C</strong></li>
<li>正确的说法是 <strong>十进制数码的ASCII码&#x3D;十进制数码的BCD码+30h</strong>。正确答案: <strong>D</strong></li>
</ol>
<h2 id="二-用一条指令写出实现下列指明的功能"><a href="#二-用一条指令写出实现下列指明的功能" class="headerlink" title="二.用一条指令写出实现下列指明的功能"></a>二.用一条指令写出实现下列指明的功能</h2><ol>
<li>截取BL寄存器的低4位。</li>
<li>将AX寄存器高4位清0。</li>
<li>将CX 寄存器D14位设置为1，其余位保持不变。</li>
<li>将AL中的低4位代码变反，而其高4位代码不变。</li>
<li>测试AL最低位是否为1。</li>
<li>完成将AX清零，并使标志位CF清零。</li>
<li>AX的内容加1。要求不影响CF。</li>
<li>传送25H到AL寄存器。</li>
<li>AL内容乘以BL内容。</li>
<li>AX内容乘以BX内容。</li>
<li>将AL寄存器值乘2 。</li>
<li>AX寄存器的值入栈保存。</li>
<li>把堆栈栈顶数据出栈存入BX寄存器中</li>
<li>标志寄存器的值入栈保存。</li>
<li>把堆栈弹出数据送入标志寄存器中</li>
<li>将BL寄存器值减1。</li>
<li>将BL寄存器值加1。</li>
<li>把数0A0H与AL寄存器的内容相加,并把结果送回AL中。</li>
<li>把数0A0H、AL寄存器和进位标志相加,并把结果送回AL中。</li>
<li>把AX寄存器的值减去数789AH，并把结果送回AX中。</li>
<li>把AX寄存器的值减去数789AH和借位，并把结果送回AX中。</li>
<li>用寄存器BX和SI的基址变址寻址方式，把存储器中的一个字节与AL寄存器的内容相加，并保存在AL寄存器中。</li>
<li>用BX和位移量0B2H的寄存器相对寻址方式把一个字和CX寄存器的内容相加,并把结果送回内存中。</li>
<li>调用7CH中断</li>
<li>把DF标志设置为1</li>
<li>把DF标志清0</li>
<li>把IF标志设置为1</li>
<li>把IF标志清0</li>
<li>当CX为0时，跳转到名为S1的标号处</li>
<li>当上条运算指令结果为正数时，跳转到名为S1的标号处</li>
<li>当上条运算指令结果为负数时，跳转到名为S2的标号处</li>
</ol>
<h4 id="答案与解析-6"><a href="#答案与解析-6" class="headerlink" title="答案与解析"></a>答案与解析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">and bl, 0Fh</span><br><span class="line">and ax, 0FFFh</span><br><span class="line">or cx, 4000h</span><br><span class="line">xor al, 0Fh</span><br><span class="line">test al, 1</span><br><span class="line">xor ax, ax</span><br><span class="line">inc ax</span><br><span class="line">mov al, 25h</span><br><span class="line"> mul bl</span><br><span class="line">mul bx</span><br><span class="line">shl al, 1</span><br><span class="line">push ax</span><br><span class="line">pop bx</span><br><span class="line">pushf</span><br><span class="line">popf</span><br><span class="line">dec bl</span><br><span class="line">inc bl</span><br><span class="line">add al, 0A0h</span><br><span class="line">adc al, 0A0h</span><br><span class="line">sub ax, 789Ah</span><br><span class="line">sbb ax, 789Ah</span><br><span class="line">add al, [bx+si]</span><br><span class="line">add [bx+0B2h], cx</span><br><span class="line">int 7Ch</span><br><span class="line">std</span><br><span class="line">cld</span><br><span class="line">sti</span><br><span class="line">cli</span><br><span class="line">jcxz S1</span><br><span class="line">jns S1</span><br><span class="line">js S2</span><br></pre></td></tr></table></figure>

<h2 id="三-程序分析"><a href="#三-程序分析" class="headerlink" title="三.程序分析"></a>三.程序分析</h2><ol>
<li>以下程序计算2^8，选一个数据补全程序。（  ）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs：code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start： mov ax,2</span><br><span class="line">         mov  cx,_____</span><br><span class="line">    s：  add ax,ax</span><br><span class="line">         loop s</span><br><span class="line">         mov  ax,4c00h</span><br><span class="line">         int  21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>A. 8   B. 7   C. 4   D. 128</p>
<ol start="2">
<li>如下程序执行后，AX&#x3D;（  ）。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> assume cs：code </span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start： mov ax,2</span><br><span class="line">         mov  bx,2</span><br><span class="line"></span><br><span class="line">         mov  cx,0</span><br><span class="line">s： add ax,bx</span><br><span class="line">         loop s</span><br><span class="line">         mov  ax,4c00h</span><br><span class="line">         int  21h</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>A. 2    B. 4    C. 0FFFEH   D. 0FFFCH</p>
<ol start="3">
<li>以下指令执行后，10000H~10006H内存单元中的内容是（  ）。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,1000H </span><br><span class="line">MOV DS,AX </span><br><span class="line">MOV BX,0000H </span><br><span class="line">MOV AX,3E88H </span><br><span class="line">MOV [BX],AX </span><br><span class="line">INC BX </span><br><span class="line">INC BX </span><br><span class="line">MOV [BX],AH </span><br><span class="line">MOV AH,0 </span><br><span class="line">INC BX </span><br><span class="line">MOV [BX],AX </span><br><span class="line">INC BX </span><br><span class="line">MOV [BX],AX </span><br><span class="line">MOV AX,DS：[1] </span><br><span class="line">INC BX </span><br><span class="line">INC BX </span><br><span class="line">MOV [BX],AX</span><br></pre></td></tr></table></figure>

<p>A.88H,3EH,3EH,88H,88H,00H,3EH</p>
<p>B.88H,3EH,3EH,88H,00H,88H,00H</p>
<p>C.88H,3EH,3EH,88H,00H,3EH,3EH</p>
<p>D.88H,3EH,3EH,88H,88H,3EH,3EH</p>
<ol start="4">
<li>补全以下程序，计算00101000h-00202000h的值，并将计算结果的高位保存在AX中，低位保存在BX中。（ ）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,0010H</span><br><span class="line">MOV BX,1000H</span><br><span class="line">___________</span><br><span class="line">___________</span><br></pre></td></tr></table></figure>

<p>A.SUB BX,2000H   B.SBB BX,2000H</p>
<p>SUB AX,0020H     SUB AX,0020</p>
<p>C.SUB BX,2000H   D.SBB BX,2000H</p>
<p>SBB AX,0020H    SBB AX,0020H</p>
<ol start="5">
<li>补全程序，使其可以实现.SUM&#x3D;字符串STR中的所有BYTE型数据的和。（  ）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">   ASSUME CS：CODE,ES：DATA</span><br><span class="line"></span><br><span class="line">DATA SEGMENT</span><br><span class="line"></span><br><span class="line">    STR  DB &#x27;NULL POINTER ASSIGNMENT.&#x27;</span><br><span class="line"></span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">CODE SEGMENT</span><br><span class="line">    SUM  DW   0</span><br><span class="line">START：MOV AX,DATA</span><br><span class="line"></span><br><span class="line">         MOV  ____,AX</span><br><span class="line"></span><br><span class="line">         MOV  SI,0</span><br><span class="line"></span><br><span class="line">         MOV  CX,24</span><br><span class="line"></span><br><span class="line">S：MOV AL,STR[SI]</span><br><span class="line"></span><br><span class="line">         ADD  ____,AL</span><br><span class="line"></span><br><span class="line">         ADC  BYTE PTR SUM[1],0</span><br><span class="line"></span><br><span class="line">         LOOP S</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">         MOV  AX,4C00H</span><br><span class="line"></span><br><span class="line">         INT  21H</span><br><span class="line"></span><br><span class="line">CODE ENDS</span><br><span class="line"></span><br><span class="line">END START  </span><br></pre></td></tr></table></figure>

<p>A.DS，SUM[2]       B.ES，SUM[2]</p>
<p>C.ES，BYTE PTR SUM[0]  D.DS，BYTE PTR SUM[0]</p>
<ol start="6">
<li>以下程序实现将data段中的大写字母转换为小写，小写字母转换为大写。补全程序。（  ）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> ASSUME CS：CODE</span><br><span class="line"></span><br><span class="line">DATA SEGMENT</span><br><span class="line">         DB &quot;heLLo&quot;</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">CODE SEGMENT</span><br><span class="line"></span><br><span class="line">START：MOV AX,DATA</span><br><span class="line">         MOV  DS,AX</span><br><span class="line"></span><br><span class="line">         MOV  BX,0</span><br><span class="line">         MOV  CX,5</span><br><span class="line">S：ADD BYTE PTR [BX],00100000B ；加上20h，大写变小写，小写多加</span><br><span class="line">         AND  BYTE PTR [BX],_________ ；</span><br><span class="line"></span><br><span class="line">         OR   BYTE PTR [BX],01100000B  ；D6D5位置1</span><br><span class="line"></span><br><span class="line">         INC  BX</span><br><span class="line"></span><br><span class="line">         LOOP S</span><br><span class="line"></span><br><span class="line">         MOV  AX,4C00H</span><br><span class="line"></span><br><span class="line">         INT  21H</span><br><span class="line">CODE ENDS</span><br><span class="line"></span><br><span class="line">END START</span><br></pre></td></tr></table></figure>

<p>A.01H   B.00H   C.80H   D.7FH    E.前几个选项都不对</p>
<ol start="7">
<li>下面的程序统计1000：0处的32个字节型整数中，其值在[-64,-16]中的数据的个数，结果存在DX中。补全这个程序。（ ）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000h</span><br><span class="line"></span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov dx,0</span><br><span class="line"></span><br><span class="line">mov cx,32</span><br><span class="line"></span><br><span class="line">s：  mov al,0</span><br><span class="line"></span><br><span class="line">________</span><br><span class="line"></span><br><span class="line">cmp al,16</span><br><span class="line"></span><br><span class="line">________</span><br><span class="line"></span><br><span class="line">cmp al,64</span><br><span class="line"></span><br><span class="line">________</span><br><span class="line"></span><br><span class="line">inc dx</span><br><span class="line"></span><br><span class="line">s0： inc bx</span><br><span class="line"></span><br><span class="line">loop s</span><br></pre></td></tr></table></figure>

<p>A.   or al,[bx]；jmp ax；shr al,1</p>
<p>B.   add al,[bx]；jnb s0；jna s0</p>
<p>C.   and al,[bx]；je s0；je s</p>
<p>D.   sub al,[bx]；jb s0；ja s0</p>
<p>E． 前几个选项都不对。</p>
<ol start="8">
<li><p>补全程序，使其可以实现将“assembly”复制到0：200处的内存空间中。（  ）</p>
<p>assume cs：code,ds：data<br>  data segment<br>   db ‘assembly’<br>   data ends<br> code segment</p>
<p> start： mov ax,data</p>
<p> mov ds,ax</p>
<p> mov si,___</p>
<p> mov ax,0</p>
<p> mov es,ax</p>
<p> mov di,___</p>
<p> mov cx,___</p>
<p> std</p>
<p> rep movsw</p>
<p> mov ax,4c00h</p>
<p> int 21h<br>  code ends<br>  end start</p>
</li>
</ol>
<p>A.6，206h，4</p>
<p>B.8，208h，4</p>
<p>C.0，200h，8</p>
<p>D.0，200h，4</p>
<ol start="9">
<li>补全程序，使其可以实现(AX)&#x3D;2^10。（  ）</li>
</ol>
<p> mov ax,2</p>
<p>mov cx,___<br>s： add ax,ax</p>
<p>   loop s</p>
<p>A.8           B.9           C.10               D.11</p>
<ol start="10">
<li>以下程序执行后，ax的值是（  ）。</li>
</ol>
<p>assembly<br>mov ax,0<br>push ax</p>
<p> popf ;标志寄存器值为0</p>
<p> mov ax,0fff0h</p>
<p> add ax,88h ;结果是0078H，OF&#x3D;0,SF&#x3D;0,ZF&#x3D;0,PF&#x3D;1,CF&#x3D;1</p>
<p> Pushf  ;标志寄存器压入堆栈</p>
<p> pop ax ;栈顶弹出一个字到ax，即标志寄存器值</p>
<p> and al,11000101b ;保留AX的D7（sf） D6（zf） D2（pf） D0（cf）位，其余清0</p>
<p> and ah,10001000b ;保留AX的D15（0） D11（of）位，其余清0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">参考.标志寄存器</span><br><span class="line"></span><br><span class="line">15   14   13   12   11   10   9    8    7    6    5    4     3    2    1    0</span><br><span class="line"></span><br><span class="line">                   OF  DF  IF   TF   SF   ZF       AF          PF       CF</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A. 1h   B. 804h  C. 5h    D. 前三个选项都不对</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">11.   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```assembly</span><br><span class="line"> assume cs：code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line"></span><br><span class="line">          db 16 dup(0)</span><br><span class="line"></span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start： mov ax,stack</span><br><span class="line">         mov  ss,ax</span><br><span class="line"></span><br><span class="line">         mov  sp,16</span><br><span class="line">         mov  ax,sp</span><br><span class="line"></span><br><span class="line">         push cs</span><br><span class="line"></span><br><span class="line">         call s</span><br><span class="line"></span><br><span class="line">         sub  ax,sp</span><br><span class="line"></span><br><span class="line">s：pop ax</span><br><span class="line">         mov  ax,4c00h</span><br><span class="line"></span><br><span class="line">         int  21h</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>这个程序加载到内存后，其一段程序所在的内存空间的情况如下：</p>
<p>内存地址  机器码   所对应的源程序中的指令</p>
<p>1000：0008 8BC4    mov ax,sp</p>
<p>1000：000A 0E     push cs</p>
<p>1000：000B E80200   call s</p>
<p>1000：000E 2BC4    sub ax,sp</p>
<p>1000：0010 58    s：pop ax</p>
<p>执行这个程序，“pop ax”执行后，ax的值为（ ）。</p>
<p>A. 8h   B. 0bh  C. 0eh  D. 1000h  E. 2  F. 10h</p>
<ol start="12">
<li>以下程序计算(345-333)^2，结果存在dx.ax中。补全这个程序。（  ）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> assume cs：code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start： mov ax,333</span><br><span class="line"></span><br><span class="line">         push ax</span><br><span class="line"></span><br><span class="line">         mov  ax,345</span><br><span class="line"></span><br><span class="line">         push ax</span><br><span class="line"></span><br><span class="line">         call calc</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">         mov  ax,4c00h</span><br><span class="line"></span><br><span class="line">         int  21h</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">calc： push bp</span><br><span class="line"></span><br><span class="line">         mov  bp,sp</span><br><span class="line"></span><br><span class="line">         mov  ax,_____</span><br><span class="line"></span><br><span class="line">         sub  ax,_____</span><br><span class="line"></span><br><span class="line">         mov  bp,ax</span><br><span class="line"></span><br><span class="line">         mul  bp</span><br><span class="line"></span><br><span class="line">         pop  bp</span><br><span class="line"></span><br><span class="line">         ret  4</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>A.[bp+6]，[bp+8]    B.[bp+4]，[bp+6]</p>
<p>C.[bp+2]，[bp+4]    D.[bp+4]，[bp+2]</p>
<ol start="13">
<li>以下程序统计0f123：0处的32个字节中，大小在(15，100]的数据的个数，结果存在dx中。补全这个程序。（  ）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0f123h</span><br><span class="line"></span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov dx,0</span><br><span class="line"></span><br><span class="line">mov cx,32</span><br><span class="line"></span><br><span class="line">s： mov al,[bx]</span><br><span class="line"></span><br><span class="line">cmp al,15</span><br><span class="line"></span><br><span class="line">_________</span><br><span class="line"></span><br><span class="line">cmp al,100</span><br><span class="line"></span><br><span class="line">_________</span><br><span class="line"></span><br><span class="line">inc dx</span><br><span class="line"></span><br><span class="line">s0：inc bx</span><br><span class="line"></span><br><span class="line">loop s</span><br></pre></td></tr></table></figure>

<ol start="14">
<li>以下程序统计0f123：0处的32个字节中，大小在(-100，0）的数据的和，结果存在dx中。补全这个程序。（  ）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0f123h</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov dx,0</span><br><span class="line">mov cx,32</span><br><span class="line">s： mov al,[bx]</span><br><span class="line">_________</span><br><span class="line">cmp al,-100</span><br><span class="line">_________</span><br><span class="line">cmp al,0</span><br><span class="line"></span><br><span class="line">_________</span><br><span class="line"></span><br><span class="line">add dx，ax</span><br><span class="line"></span><br><span class="line">s0：inc bx</span><br><span class="line"></span><br><span class="line">  loop s</span><br></pre></td></tr></table></figure>

<ol start="15">
<li>以下程序执行到(cx)&#x3D;0时，CPU几次修改IP？（ ）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov cx,2</span><br><span class="line"></span><br><span class="line">s ax,bx</span><br><span class="line"></span><br><span class="line">loop s</span><br></pre></td></tr></table></figure>

<p> A. 3   B. 5    C. 6   D. 7   E. 8   F. 9</p>
<ol start="16">
<li>用debug查看内存，结果如下.</li>
</ol>
<p> 2000：0200 00 01 02 03 04 05 06 07-08 09 0A 0B 0C 0D 0E 0F</p>
<p>2000：0210 10 11 12 13 14 15 16 17-18 19 1A 1B 1C 1D 1E 1F</p>
<p>下面的程序执行后，ax、cx、dx中的内容依次是（  ）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1fffh</span><br><span class="line"></span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov ss,ax</span><br><span class="line"></span><br><span class="line">mov bx,210h</span><br><span class="line"></span><br><span class="line">mov sp,bx</span><br><span class="line"></span><br><span class="line">mov ax,[bx] </span><br><span class="line"></span><br><span class="line">mov cx,[bx+12h]</span><br><span class="line"></span><br><span class="line">pop dx</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>A.未知，未知，未知      B.0100h，1312h，未知</p>
<p>C.0001h，1213h，1415h     D.0100h，1312h，0100h</p>
<ol start="17">
<li>补全程序，使其可以实现.累加a处的8个数据，结果存在b处的双字中。（  ）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs：code,ds：data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line"></span><br><span class="line">a dw 1,2,3,4,5,6,7,8</span><br><span class="line"></span><br><span class="line">b dd 0</span><br><span class="line"></span><br><span class="line">c dw a,b</span><br><span class="line"></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line"></span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>A. start： mov ax,data</p>
<p>mov ds,ax</p>
<p>mov si,0</p>
<p>mov cx,8</p>
<p>s： mov ax,a[si]</p>
<p>add b[0],ax</p>
<p>adc b[2],ax</p>
<p>add si,2</p>
<p>loop s</p>
<p>B. start： mov si,0</p>
<p>mov cx,8</p>
<p>s： mov ax,a[si]</p>
<p>add word ptr b[0],ax</p>
<p>adc word ptr b[2],0</p>
<p>add si,1</p>
<p>loop s</p>
<p>C. start： mov ax,seg a</p>
<p>mov ds,ax</p>
<p>mov si,0</p>
<p>mov cx,8</p>
<p>s： mov ax,a[si]</p>
<p>mov bx,offset b</p>
<p>   add word ptr[bx],ax</p>
<p>adc word ptr 2[bx],0</p>
<p>add si,2</p>
<p>loop s</p>
<p>D. start： mov ax,data</p>
<p>mov ds,ax</p>
<p>mov si,0</p>
<p>mov cx,8</p>
<p>s： mov ax,a[si]</p>
<p>mov bx,word ptr c[0]</p>
<p>add word ptr [bx],ax</p>
<p>mov bx,word ptr c[2]</p>
<p>adc word ptr[bx],0</p>
<p>add si,2</p>
<p>loop s</p>
<ol start="18">
<li>补全程序，使其可以实现.将data段中的字符串转化为大写。（  ）</li>
</ol>
<p>assume cs：code</p>
<p>data segment</p>
<p>db ‘conversation’,0</p>
<p>data ends</p>
<p>code segment</p>
<p>start：</p>
<p>mov ax,data</p>
<p>mov ds,ax</p>
<p>mov si,0</p>
<p>mov cx,12</p>
<p>call capital</p>
<p>mov ax,4c00h</p>
<p>int 21h</p>
<p>capital：</p>
<p>……</p>
<p>code ends</p>
<p>end start</p>
<p>A.   or byte ptr [si],00100000b</p>
<p>inc si</p>
<p>loop capital</p>
<p>ret</p>
<p>B.   mov cl,[si]</p>
<p>mov ch,0</p>
<p>jcxz ok</p>
<p>sub word ptr [si],20h</p>
<p>inc si</p>
<p>inc si</p>
<p>jmp short capital</p>
<p>ok： ret</p>
<p>C.     mov cl,11011111b</p>
<p>s： push cx</p>
<p>and byte ptr [si],cl</p>
<p>inc si</p>
<p>pop cx</p>
<p>loop s</p>
<p>ok： ret</p>
<p>D.   mov cl,[si]</p>
<p>mov ch,0</p>
<p>inc cx</p>
<p>loop ok</p>
<p>ret</p>
<p>ok： and byte ptr [si],11011111b</p>
<p>inc si</p>
<p>jmp capital</p>
<ol start="19">
<li>以下程序中所有的转移指令的机器码都是两个字节。用一条指令补全程序，使其可以由代码段中的程序段返回。（  ）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> assume cs：code</span><br><span class="line">code segment</span><br><span class="line">         mov           ax,4c00h</span><br><span class="line">         int           21h</span><br><span class="line">start：</span><br><span class="line">         nop</span><br><span class="line">         nop</span><br><span class="line">         push          cs</span><br><span class="line">         pop           ds</span><br><span class="line">         mov           si,offset o</span><br><span class="line">         mov           di,offset start</span><br><span class="line">         mov           ax,ds：[si]</span><br><span class="line">         mov           ds：[di],ax</span><br><span class="line">         mov           cx,-2</span><br><span class="line">s：</span><br><span class="line">         jcxz          start</span><br><span class="line">         _____________</span><br><span class="line"></span><br><span class="line">o： loop s</span><br><span class="line">code ends</span><br><span class="line">  end start</span><br></pre></td></tr></table></figure>

<p>A.add cx,2(机器码：83H C1H 02H)</p>
<p>B.add cx,1(机器码：83H C1H 01H)</p>
<p>C.inc cx(机器码：41H)</p>
<p>D.以上都不对</p>
<ol start="20">
<li>用debug查看内存单元，结果如下。则执行以下程序，ax的值是多少？（  ）</li>
</ol>
<p>1100：F000 BE 00 06 00 6A 22</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,2000H</span><br><span class="line"></span><br><span class="line">MOV DS,AX</span><br><span class="line"></span><br><span class="line">MOV BX,0000H</span><br><span class="line"></span><br><span class="line">MOV SI,0</span><br><span class="line"></span><br><span class="line">MOV AX,2[BX][SI]  </span><br><span class="line"></span><br><span class="line">INC SI</span><br><span class="line"></span><br><span class="line">ADD AX,2[BX][SI]   </span><br><span class="line"></span><br><span class="line">INC SI</span><br><span class="line"></span><br><span class="line">MOV DI,SI</span><br><span class="line"></span><br><span class="line">SUB AX,2[BX][DI]  </span><br></pre></td></tr></table></figure>


<p>A.9C06H    B.479CH   C.7006H   D.8C70H</p>
<ol start="21">
<li>下面的程序执行后，AX中的数值为多少？</li>
</ol>
<p>内存地址 机器码 汇编指令</p>
<p>1000:0 B8 00 00 MOV AX,0</p>
<p>1000:3 E8 01 00 CALL S</p>
<p>1000:6 40 INC AX</p>
<p>1000:7 58 S:POP AX</p>
<ol start="22">
<li>下面的程序执行后，AX中的数值为多少？</li>
</ol>
<p>内存地址 机器码 汇编指令</p>
<p>1000:0 B8 00 00 MOV AX,0</p>
<p>1000:3 9A 09 00 00 10 CALL FAR PTR S</p>
<p>1000:8 40 INC AX</p>
<p>1000:9 58 S:POP AX</p>
<p>ADD AX,AX</p>
<p>POP BX</p>
<p>ADD AX,BX</p>
<ol start="23">
<li>下面的程序执行后，AX中的数值为多少？</li>
</ol>
<p>内存地址 机器码 汇编指令</p>
<p>1000:0 B8 06 00 MOV AX,6</p>
<p>1000:2 FF D0 CALL AX</p>
<p>1000:5 40 INC AX</p>
<p>1000:6 MOV BP,SP</p>
<p>ADD AX,[BP]</p>
<ol start="24">
<li>程序如下。</li>
</ol>
<p>ASSUME CS:CODE</p>
<p>DATA SEGMENT</p>
<p>？</p>
<p>DATA ENDS</p>
<p>CODE SEGMENT</p>
<p>START: MOV AX,DATA</p>
<p>MOV DS,AX</p>
<p>MOV BX,0</p>
<p>JMP WORD PTR [BX+1]</p>
<p>CODE ENDS</p>
<p>END START</p>
<p>若要使程序中的JMP指令执行后，CS:IP指向程序的第一条指令，在DATA段中应该定义哪些数据?</p>
<ol start="25">
<li>程序如下。</li>
</ol>
<p>ASSUME CS:CODE,DS:DATA</p>
<p>DATA SEGMENT</p>
<p>DD 12345678H</p>
<p>DATA ENDS</p>
<p>CODE SEGMENT</p>
<p>START: MOV AX,DATA</p>
<p>MOV DS,AX</p>
<p>MOV BX,0</p>
<p>MOV [BX],_______</p>
<p>MOV [BX+2],_________</p>
<p>JMP DWORD PTR DS:[0]</p>
<p>CODE ENDS</p>
<p>END START</p>
<p>补全程序，使JMP指令执行后，CS:IP指向程序的第一条指令。</p>
<ol start="26">
<li>用DEBUG查看内存，结果如下：</li>
</ol>
<p>2000:1000 BE 00 06 00 00 00 ……</p>
<p>则此时，CPU执行指令：</p>
<p>MOV AX,2000H</p>
<p>MOV ES,AX</p>
<p>JMP DWORD PTR ES:[1000H]</p>
<p>后，(CS)&#x3D;? , (IP)&#x3D;?</p>
<ol start="27">
<li>补全下面的程序，统计F000:0处32个字节中，大小在[32,128]的数据的个数。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0f000h</span><br><span class="line"></span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov dx,0</span><br><span class="line"></span><br><span class="line">mov cx,32</span><br><span class="line"></span><br><span class="line">s:mov al,[bx]</span><br><span class="line"></span><br><span class="line">cmp al,32</span><br><span class="line"></span><br><span class="line">_________</span><br><span class="line"></span><br><span class="line">cmp al,120</span><br><span class="line"></span><br><span class="line">__________</span><br><span class="line"></span><br><span class="line">inc dx</span><br><span class="line"></span><br><span class="line">s0:inc bx</span><br><span class="line"></span><br><span class="line">loop s</span><br></pre></td></tr></table></figure>

<ol start="28">
<li>补全下面的程序，统计F000:0处32个字节中，大小在(-32,32)的数据的个数。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0f000h</span><br><span class="line"></span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov dx,0</span><br><span class="line"></span><br><span class="line">mov cx,32</span><br><span class="line"></span><br><span class="line">s:mov al,[bx]</span><br><span class="line"></span><br><span class="line">cmp al,32</span><br><span class="line"></span><br><span class="line">__________</span><br><span class="line"></span><br><span class="line">cmp al,120</span><br><span class="line"></span><br><span class="line">___________</span><br><span class="line"></span><br><span class="line">inc dx</span><br><span class="line"></span><br><span class="line">s0:inc bx</span><br><span class="line"></span><br><span class="line">loop s</span><br></pre></td></tr></table></figure>

<p>(1) 程序如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line"></span><br><span class="line">?</span><br><span class="line"></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start: mov ax,data</span><br><span class="line"></span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">jmp word ptr [bx+1]</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>若要使程序中的jmp指令执行后，CS:IP指向程序的第一条指令，在data段中应该定义哪些数据?</p>
<p>(2) 程序如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line"></span><br><span class="line">dd 12345678h</span><br><span class="line"></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start: mov ax,data</span><br><span class="line"></span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">_______________________</span><br><span class="line"></span><br><span class="line">________________________</span><br><span class="line"></span><br><span class="line">jmp dword ptr ds:[0]</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>补全程序，使jmp指令执行后，CS:IP指向程序的第一条指令。</p>
<p>(3)用Debug查看内存，结果如下：</p>
<p>2000:1000 BE 00 06 00 00 00 ……</p>
<p>则此时，CPU执行指令：</p>
<p>mov ax,2000H</p>
<p>mov es,ax</p>
<p>jmp dword ptr es:[1000H]</p>
<p>后，(CS)&#x3D;? , (IP)&#x3D;?</p>
<h4 id="答案与解析-7"><a href="#答案与解析-7" class="headerlink" title="答案与解析"></a>答案与解析</h4><ol>
<li><p>正确答案是 B. 7。2^1 *2^7&#x3D;2^8,所以循环7次就行</p>
</li>
<li><p>AX的初始值是2，BX也是2。程序中没有循环，因此AX的值不会改变。正确答案是 A. 2。</p>
</li>
<li><p>C.88H,3EH,3EH,88H,00H,3EH,3EH。</p>
</li>
<li><p>正确的指令是 D. SBB BX,2000H 和 SBB AX,0020H。</p>
</li>
<li><p>正确答案是 D. DS，BYTE PTR SUM[0]。</p>
</li>
<li><p>正确的指令是 AND BYTE PTR [BX],7FH。</p>
</li>
<li><p>正确的指令是 D. sub al,[bx]；jb s0；ja s0。</p>
</li>
<li><p>正确答案是 C.0，200h，8。</p>
</li>
<li><p>正确答案是 B.9。</p>
</li>
<li><p>答案是 B. 804h1。</p>
</li>
<li><p>答案是 A. 8h。</p>
</li>
<li><p>答案是 C. [bp+2]，[bp+4]。</p>
</li>
<li><p>答案是 jg s0 和 jle s0</p>
</li>
<li><p>答案是 test al, al 和 jge s0。</p>
</li>
<li><p>答案是 C. 66。</p>
</li>
<li><p>答案是 C. 0001h，1213h，1415h7。</p>
</li>
<li><p>正确的答案是 <strong>D</strong>。</p>
</li>
<li><p>对于第18题，正确的答案是 <strong>C</strong>。</p>
</li>
<li><p>对于第19题，正确的答案是 <strong>A</strong>。</p>
</li>
<li><p><code>ax</code>寄存器的值是 <strong>D.8C70H</strong>。</p>
<p>后面的都是程序设计，懒得弄了，自己看吧</p>
</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>教材中的检测点</li>
<li>实验1~实验九</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://kashima19960.github.io">木人舟</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://kashima19960.github.io/2024/10/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E9%A2%98%E5%BA%93%E7%AD%94%E6%A1%88%E4%B8%8E%E8%A7%A3%E6%9E%902024%E7%89%88/">https://kashima19960.github.io/2024/10/12/汇编语言/汇编语言题库答案与解析2024版/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://kashima19960.github.io" target="_blank">木人舟的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">汇编语言</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/kashima19960/img@master/%E5%85%B6%E4%BB%96/86.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/13/Linux/wsl2%E5%90%AF%E7%94%A8%E4%BB%A3%E7%90%86(%E6%A2%AF%E5%AD%90)%E7%9A%84%E6%96%B9%E6%B3%95/" title="wsl2启用代理(梯子)的方法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">wsl2启用代理(梯子)的方法</div></div></a></div><div class="next-post pull-right"><a href="/2024/10/09/QtDesign%E9%A2%84%E8%A7%88%E7%9A%84%E6%95%88%E6%9E%9C%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BB%93%E6%9E%9C%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" title="QtDesign预览的效果与程序运行结果不一致的解决方法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">QtDesign预览的效果与程序运行结果不一致的解决方法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/10/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E7%8E%8B%E7%88%BD%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E7%89%88%E5%AE%9E%E9%AA%8C1/" title="王爽汇编语言第三版实验1"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-04</div><div class="title">王爽汇编语言第三版实验1</div></div></a></div><div><a href="/2024/10/05/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E7%8E%8B%E7%88%BD%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E7%89%88%E5%AE%9E%E9%AA%8C10%E5%92%8C11/" title="王爽汇编语言第三版实验10和11"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-05</div><div class="title">王爽汇编语言第三版实验10和11</div></div></a></div><div><a href="/2024/10/05/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E7%8E%8B%E7%88%BD%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E7%89%88%E5%AE%9E%E9%AA%8C12/" title="王爽汇编语言第三版实验12"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-05</div><div class="title">王爽汇编语言第三版实验12</div></div></a></div><div><a href="/2024/10/05/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E7%8E%8B%E7%88%BD%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E7%89%88%E5%AE%9E%E9%AA%8C13/" title="王爽汇编语言第三版实验13"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-05</div><div class="title">王爽汇编语言第三版实验13</div></div></a></div><div><a href="/2024/10/05/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E7%8E%8B%E7%88%BD%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E7%89%88%E5%AE%9E%E9%AA%8C14/" title="王爽汇编语言第三版实验14"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-05</div><div class="title">王爽汇编语言第三版实验14</div></div></a></div><div><a href="/2024/10/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E7%8E%8B%E7%88%BD%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E7%89%88%E5%AE%9E%E9%AA%8C2/" title="王爽汇编语言第三版实验2"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-04</div><div class="title">王爽汇编语言第三版实验2</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><span id="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/kashima19960/img@master/%E5%85%B6%E4%BB%96/86.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">木人舟</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kashima19960"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/kashima19960" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/CodingCV@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">阅读文章遇到问题可以发消息到我的邮箱——CodingCV@outlook.com</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%8D%95%E9%80%89%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">一 单选题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0"><span class="toc-number">2.1.</span> <span class="toc-text">第一章</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%94%E6%A1%88%E4%B8%8E%E8%A7%A3%E6%9E%90"><span class="toc-number">2.1.1.</span> <span class="toc-text">答案与解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2-3%E7%AB%A0"><span class="toc-number">2.2.</span> <span class="toc-text">第2~3章</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%94%E6%A1%88%E4%B8%8E%E8%A7%A3%E6%9E%90-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">答案与解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4-6%E7%AB%A0"><span class="toc-number">2.3.</span> <span class="toc-text">第4~6章</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%94%E6%A1%88%E4%B8%8E%E8%A7%A3%E6%9E%90-2"><span class="toc-number">2.3.1.</span> <span class="toc-text">答案与解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7-8%E7%AB%A0%EF%BC%88%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">第7-8章（寻址方式）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%94%E6%A1%88%E4%B8%8E%E8%A7%A3%E6%9E%90-3"><span class="toc-number">2.4.1.</span> <span class="toc-text">答案与解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9-10%E7%AB%A0"><span class="toc-number">2.5.</span> <span class="toc-text">第9-10章</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%94%E6%A1%88%E4%B8%8E%E8%A7%A3%E6%9E%90-4"><span class="toc-number">2.5.1.</span> <span class="toc-text">答案与解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0"><span class="toc-number">2.6.</span> <span class="toc-text">第11章</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%94%E6%A1%88%E4%B8%8E%E8%A7%A3%E6%9E%90-5"><span class="toc-number">2.6.1.</span> <span class="toc-text">答案与解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%94%A8%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4%E5%86%99%E5%87%BA%E5%AE%9E%E7%8E%B0%E4%B8%8B%E5%88%97%E6%8C%87%E6%98%8E%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">3.</span> <span class="toc-text">二.用一条指令写出实现下列指明的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%94%E6%A1%88%E4%B8%8E%E8%A7%A3%E6%9E%90-6"><span class="toc-number">3.0.1.</span> <span class="toc-text">答案与解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">三.程序分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%94%E6%A1%88%E4%B8%8E%E8%A7%A3%E6%9E%90-7"><span class="toc-number">4.0.1.</span> <span class="toc-text">答案与解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">5.</span> <span class="toc-text">其他</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/14/%E5%BE%AE%E6%9C%BA/%E7%AE%80%E7%AD%94%E9%A2%98%E9%A2%98%E5%BA%93%20(%E7%AD%94%E6%A1%88)/" title="《微型计算机技术与应用》期末考试题库简答题答案">《微型计算机技术与应用》期末考试题库简答题答案</a><time datetime="2025-01-14T05:05:00.000Z" title="发表于 2025-01-14 13:05:00">2025-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/14/%E5%BE%AE%E6%9C%BA/%E5%A1%AB%E7%A9%BA%E9%A2%98%E9%A2%98%E5%BA%93%20(%E7%AD%94%E6%A1%88)/" title="《微型计算机技术与应用》期末考试题库填空题答案">《微型计算机技术与应用》期末考试题库填空题答案</a><time datetime="2025-01-14T04:58:00.000Z" title="发表于 2025-01-14 12:58:00">2025-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/14/%E5%BE%AE%E6%9C%BA/%E9%80%89%E6%8B%A9%E9%A2%98%E9%A2%98%E5%BA%93%20(%E7%AD%94%E6%A1%88)/" title="《微型计算机技术与应用》期末考试题库选择题答案">《微型计算机技术与应用》期末考试题库选择题答案</a><time datetime="2025-01-14T04:58:00.000Z" title="发表于 2025-01-14 12:58:00">2025-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/08/%E6%90%AD%E5%BB%BARAG%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F/" title="如何利用RAG+LLM技术拯救自己的期末考试">如何利用RAG+LLM技术拯救自己的期末考试</a><time datetime="2025-01-08T13:14:00.000Z" title="发表于 2025-01-08 21:14:00">2025-01-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/03/C%E8%AF%AD%E8%A8%80/%E8%A7%A3%E5%86%B3Vscode%E4%B8%AD%E4%BD%BF%E7%94%A8netdb.h%E7%9A%84getaddrinfo%E5%92%8Caddrinfo%E4%BC%9A%E6%8A%A5%E9%94%99%E7%9A%84%E6%96%B9%E6%B3%95/" title="解决Vscode中使用netdb.h的getaddrinfo和addrinfo会报错的方法">解决Vscode中使用netdb.h的getaddrinfo和addrinfo会报错的方法</a><time datetime="2024-12-03T15:14:00.000Z" title="发表于 2024-12-03 23:14:00">2024-12-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By 木人舟</div><div class="footer_custom_text">木人舟 ALL RIGHTS RESERVED.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><script>(() => {
  const disqus_config = function () {
    this.page.url = 'https://kashima19960.github.io/2024/10/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E9%A2%98%E5%BA%93%E7%AD%94%E6%A1%88%E4%B8%8E%E8%A7%A3%E6%9E%902024%E7%89%88/'
    this.page.identifier = '/2024/10/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E9%A2%98%E5%BA%93%E7%AD%94%E6%A1%88%E4%B8%8E%E8%A7%A3%E6%9E%902024%E7%89%88/'
    this.page.title = '汇编语言期末复习题库，答案与解析'
  }

  const disqusReset = () => {
    window.DISQUS && window.DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addGlobalFn('themeChange', disqusReset, 'disqus')

  const loadDisqus = () =>{
    if (window.DISQUS) disqusReset()
    else {
      const script = document.createElement('script')
      script.src = 'https://.disqus.com/embed.js'
      script.setAttribute('data-timestamp', +new Date())
      document.head.appendChild(script)
    }
  }

  const getCount = async() => {
    try {
      const eleGroup = document.querySelector('#post-meta .disqus-comment-count')
      if (!eleGroup) return
      const cleanedLinks = eleGroup.href.replace(/#post-comment$/, '')

      const res = await fetch(`https://disqus.com/api/3.0/threads/set.json?forum=&api_key=&thread:link=${cleanedLinks}`,{
        method: 'GET'
      })
      const result = await res.json()

      const count = result.response.length ? result.response[0].posts : 0
      eleGroup.textContent = count
    } catch (err) {
      console.error(err)
    }
  }

  if ('Valine' === 'Disqus' || !true) {
    if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
    else {
      loadDisqus()
      GLOBAL_CONFIG_SITE.isPost && getCount()
    }
  } else {
    window.loadOtherComment = loadDisqus
  }
})()</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>