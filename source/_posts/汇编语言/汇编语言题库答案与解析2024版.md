---
title: 汇编语言期末复习题库，答案与解析
date: 2024-10-12 15:10:02
tags: 汇编语言
---
## 前言

临时抱佛脚专用，拿着它速通汇编语言吧！😈😈，还有就是，答案与解析都是基于web search 的GenAL生成的，所以在计算题上会错误比较多，这个就自己想想办法吧，但是在概念与需要记忆的题上效果很好，自己作为参考吧😝😝😝

## 一 单选题

### 第一章

1. PC机的最小信息单位是（ ）。

A. bit   B. 字节  C. 字长    D. 字

2. 一个CPU的寻址能力是8KB，那么它的地址总线的宽度为（ ）位。

A. 8   B. 3   C. 12   D. 13

3. 1个CPU的寻址能力为16KB，那么它的地址总线的宽度为 （  ）位。

A. 11         B. 12         C. 13         D. 14

4. 1MB的存储器的地址编号从（  ）到（  ）

A.0~3ff H    B. 1~400 H         C. 0~fffff H  D. 1~100000H

5. 1TB是 （  ） 个Byte。

A. 2^40   B. 2^30   C. 2^20        D. 2^10

6. 1MB是（  ） 个Byte。

A. 2^40   B. 2^30   C. 2^20   D. 2^10

7. 1KB的存储器的地址编号从（  ）到（  ）

A. 0~3ff H        B. 1~400 H    C. 0~fffff H    D. 1~100000H

8. 1KB的存储器的可以存储（  ）个bit

A. 1024       B. 8×1024         C. 1000       D. 8000

9. 1GB是 （  ） 个Byte。

A. 2^40   B. 2^30   C. 2^20        D. 2^10

10. 8086的数据总线宽度为16根，从内存中读取20字节的数据，8086至少要读 （  ）次。

A. 16         B. 20          C. 10         D. 5

11. 8086的数据总线宽度为32根。从内存中读取20字节的数据，8086至少要读 （  ）次。

A. 32         B. 20          C. 10         D. 5

12. 在存储器中,数据和程序以_______形式存放。

A. 二进制    B. 八进制    C. 十进制    D. 十六进制

13. 8086CPU的地址总线的宽度是20位，数据总线的宽度是16位，则8086CPU的寻址能力为(  )。

A.64KB   B.1MB   C.1GB   D.不确定

14. 8086CPU的地址总线宽度为32根，8086CPU的寻址能力是（  ）。

A.64KB  B.1024KB  C.16MB   D.4096MB

15. 从内存中读取1024个字节的数据，8086CPU至少需要读256次，则8086的数据总线宽度为（  ）位。

A.4    B.8   C.16   D.32

16. 8086中，一个字单元可以存储（  ）个bit。

A.1  B.8  C.16   D.32

17. 一个1KB的存储器包含多少个存储单元？可以存储多少个二进制位？（  ）

A. 1024，1024  B. 8192，1024   C. 8192，8192   D. 1024，8192

#### 答案与解析

1. PC机的最小信息单位是字节
2. 一个CPU的寻址能力是8KB，那么它的地址总线的宽度为13位。因为13根地址总线可以寻址2^13=8KB。
3. 一个CPU的寻址能力为16KB，那么它的地址总线的宽度为14位。因为14根地址总线可以寻址2^14=16KB。
4. 1MB的存储器的地址编号从0x00000到0xFFFFF。1MB等于2^20字节，其十六进制表示为0x100000，因此地址范围为0x00000~0xFFFFF。
5. 1TB是2^40个Byte。在计算机存储界，K、M、G、T为二进制单位，所以1TB=1024GB=1024*1024MB=1024*1024*1024KB=1024*1024*1024*1024Byte=2^40Byte。
6. 1MB是2^20个Byte。1MB=1024KB=1024*1024Byte=2^20Byte。
7. 1KB的存储器的地址编号从0x000到0x3FF。1KB等于2^10字节，其十六进制表示为0x400，因此地址范围为0x000~0x3FF。
8. 1KB的存储器可以存储8192个bit。因为1KB=1024Byte，而1Byte=8bit，所以1KB=1024*8bit=8192bit。
9. 1GB是2^30个Byte。1GB=1024MB=1024*1024KB=1024*1024*1024Byte=2^30Byte。
10. 8086的数据总线宽度为16根，从内存中读取20字节的数据，8086至少要读10次。因为每次可以读取16位（即2字节），所以20字节需要10次读取。
11. 8086的数据总线宽度为32根，从内存中读取20字节的数据，8086至少要读5次。因为每次可以读取32位（即4字节），所以20字节需要5次读取。
12. 在存储器中，数据和程序以二进制形式存放。
13. 8086CPU的地址总线的宽度是20位，数据总线的宽度是16位，则8086CPU的寻址能力为1MB。因为20位地址总线可以寻址2^20=1MB。
14. 8086CPU的地址总线宽度为32根，8086CPU的寻址能力是4GB。因为32位地址总线可以寻址2^32=4GB。
15. 从内存中读取1024个字节的数据，8086CPU至少需要读256次，则8086的数据总线宽度为32位。因为每次可以读取32位（即4字节），所以1024字节需要256次读取。
16. 8086中，一个字单元可以存储16个bit。因为8086的数据总线宽度为16位，所以一个字单元是16位。
17. 一个1KB的存储器包含1024个存储单元，可以存储8192个二进制位。因为1KB=1024Byte，而1Byte=8bit，所以1KB=1024*8bit=8192bit。

### 第2~3章

1. 在Debug中，用“d 075A：110 11F”查看内存，结果如下：

075A：0110 B8 00  00 FF 07 00 B8 4C — CD 21 F3 69 20 8A 03 A1

那么，字型数据 00B8H对应的地址为（ ）。

A. 076A：11  B. 076A：16    C. 076B：0    D. 无法确定

2. 给定段地址为1234H，仅通过变化偏移地址寻址，8086CPU的寻址范围为_________(物理地址）。

A、 12340H~1234FH        B、 01234H~F1234H        C、 12340H~2233FH        D、 12340H~FFFFFH

3. 给定段地址101H，仅通过变化偏移地址寻址，8086CPU可以寻址到地址为（ ）的内存单元。

   A. 0   B. 12000H   C. 10000H   D. 1FFFFH
4. 下列寄存器中，（  ）是8位寄存器。

A、 AX        B、 BL       C、 CS           D、 DI

5. 下列寄存器中，（ ）是16位寄存器

A、 AX       B、 BL       C、 CH       D、 DL

6. 下列说法正确的是（ ）

A、 AX寄存器不能分为两个8位的寄存器

B、 BP寄存器不能分为两个8位的寄存器

C、 CS可以分为两个8位的寄存器

D、 PSW是一个通用寄存器，可以存放一般性的数据

7. 下面指令中，错误的指令是（  ）。

A、 MOV AX,1000             B、 MOV AL,BL

C、 MOV AL,1000             D、 MOV  DS,AX

8. 下面指令中，错误的指令是（  ）。

A、 MOV AX,100          B、 MOV BX,AL

C、 MOV AL,100          D、 ADD AL,BL

9. 下面指令中，正确的指令是（  ）。

A、 MOV AX,100          B、 MOV BX,AL

C、 MOV 100，AL        D、 ADD AL,1234H

10. 下面的5条指令执行后，cpu几次修改IP？（ ）

mov ax,2000H

mov bx,3000h

add ax,bx

sub bx,bx

jmp bx

A、 5        B、 6        C、 7        D、 不确定

11. 代码段寄存器是（）

A、 CS       B、 DS       C、 SS       D、 ES

12. 指令指针寄存器是（）

A、 AX       B、 BP       C、 IP        D、 DS

13. 在debug中，查看、修改CPU的寄存器内容是（ ）命令。

A、 T        B、 A        C、 E        D、 R

14. 在debug中，查看内存中的内容是（ ）命令。

A、 T        B、 A        C、 D        D、 R

15. 在debug中，修改内存中的内容是（ ）命令。

A、 T        B、 E        C、 D        D、 R

16. 在debug中，执行CS、IP指向的内存单元处的指令是（ ）命令。

A、 T        B、 E        C、 D        D、 R

17. 存储单元45A0：7CB9H的物理地址为 （  ）

A、 45AB9H      B、 4D6B9H       C、 C259H        D、 47CB9H

18. 8086CPU中，任意时刻，CPU将（ ）指向的内容当作指令来执行。

A. DS、SI   B. CS、IP   C. SS、SP   D. ES、DI

19. 下列关于Debug的说法，错误的是（ ）。

A. R命令可以修改寄存器的内容。   B. E命令可以修改内存单元的内容。

C. T命令每次只执行一条指令。    D. D命令可以查看内存单元的内容。

20. 对于8086CPU，错误的指令是（  ）。

A. mov ax,bx   B. mov ax,[bx]   C. mov ds,0   D. mov ax,0

21. 以下指令执行后，寄存器ax的值为（  ）。

mov ax, 0095h

mov ah, 95h

add al, ah

A. 9680H  B. 968AH   C. 962AH   D. 952AH

22. 关于8086CPU，下列说法错误的是（  ）。

A. 是16位结构的CPU，其能够一次性处理传输暂时存储的信息的最大长度是16bit

B. 采用“段地址×16 + 偏移地址 = 物理地址”的方式生成存储单元的地址

C. 执行push指令和pop指令时，8086CPU从SS:SP中得到栈顶的地址

D. 在编程时，可将长度为1KB的一组地址连续，起始地址为32的倍数的内存单元当成栈空间来使用。

23. 此时ax的值为00C5H，执行完“add al,85H”后，ax中的值是多少？（  ）

A.0158H  B.014AH  C.0058H  D.004AH

24. 关于汇编语言中“段”的概念，以下说法错误的是（  ）。

A.用mov、add、sub等指令通过偏移地址访问data段中的数据前，应将data段的段地址放在ds中。

B.一个段，可以既是数据段，又是桟段。

C.一个段，不可以既是代码段，又是数据段。

D.一个段中的内容对CPU来说是指令还是数据，关键在于对相关寄存器的设置。

25. 8086PC机一个段的最大长度为（  ）。

A.64Byte  B.64Kbit  C.1MB  D.64KB

26. 以下关于8086CPU的栈机制的说法，错误的是（  ）。

A.任意时刻，SS:SP指向栈顶元素。

B.retf指令不会引起栈空间超界。

C.push和pop实质上是一种内存传送指令。

D.8086CPU的栈机制，没有对避免栈空间超界提供支持。

27. 设置10000H～1FFFFH的内存空间为栈段，初始状态栈是空的，此时，SS、SP的值是（  ）。

A.SS=1000H、SP=FFFEH        B.SS=0H、SP=FFFEH

C.SS=1000H、SP=0              D.SS=2000H、SP=0

28. 完成同指令XCHG AX ,BX 相同功能的指令或指令序列是（  ）

A、 MOV AX,BX

B、 MOV BX,AX

C、 PUSH AX

POP BX

D、 MOV CX,AX

MOV AX,BX

  MOV BX,CX

29. 堆栈段段寄存器是（）

A、 CS       B、 DS       C、 SS       D、 ES

30. 堆栈指针寄存器是（）

A、 BP       B、 SP       C、 SS       D、 IP

31. 执行一次PUSH指令，SP寄存器将（ ）

A、 加1          B、 减1          C、 加2          D、 减2

32. 执行一次POP指令，SP寄存器将（ ）

A、 加1          B、 减1          C、 加2          D、 减2

33. 关于8086CPU堆栈，以下说法不正确的是（  ）

A、 操作对象是字                       B、 堆栈的长度是没有限制

C、 任何时刻，SS:SP指向栈顶元素      D、 堆栈位于内存中

34. 下面指令正确的是（ ）

A、 POP AX          B、 POP 126CH      C、 PUSH AL         D、 PUSH AX,BX

35. 8086系统中，一个堆栈最大可以设置为多少？（）

A、 1MB         B、 1KB          C、 64KB          D、 64MB

36. 如果要将20000h~21001h这段空间设置为堆栈，初始状态栈是空的，应该选择程序段（）。

A、MOV SS,20000H

MOV SP,21001H

B、MOV AX,2000H

MOV SS,AX

MOV SP,1001H

C、 MOV AX,2000H

MOV SS,AX

MOV SP,1002H

D、 MOV AX,2000H

MOV SS,AX

MOV SP,1000H

37. 设 SP初值为2000H，执行指令"PUSH AX"后，SP的值是（）

A、 1FFFH             B、1998H         C、 2002H          D、1FFEH

38. 在debug中，用“d 1000：0 0f”查看内存，结果如下。

1000:0000  89 85 4C ED 38 7B F8 10 -29 8D 44 9D 3E 75 A8 20

若DS=1000H，AX=0，那么汇编指令“MOV  AL,[0008H]”执行完后AX 的值为

A、 0H     B、 2900H         C、 0029H        D、 0010H

39. 在debug中，用“d 1000：0 0f”查看内存，结果如下。

1000:0000  89 85 4C ED 38 7B F8 10 -29 8D 44 9D 3E 75 A8 20

DS=1000H，AX=0，那么汇编指令“MOV  AX,[0008H]”执行完后AX 的值为

A、 1029H        B、 298DH        C、 2910H        D、 8D29H

40. 在debug中，用“d 1000：0 0f”查看内存，结果如下。

1000:0000  89 85 4C ED 38 7B F8 10 -29 8D 44 9D 3E 75 A8 20

1000:0010  79 87 C4 EF 25 66 F7 40 -A9 BD C4 5D 6E 7F A1 2B

1000:0020  81 15 4D ED 83 B7 8F 1A -89 7D B6 9C 3E 73 A2 21

执行前DS=0，AX=0，BX=0，那么执行下列汇编指令，完后AX 的值为（   ）

MOV AX,1002H

MOV DS,AX

MOV AX,[0]

A、 8589H        B、 8779H        C、 1581H        D、 8985H

41. 在debug中，用“d 1000：0 0f”查看内存，结果如下。

1000:0000  89 85 4C ED 38 7B F8 10 -29 8D 44 9D 3E 75 A8 20

1000:0010  79 87 C4 EF 25 66 F7 40 -A9 BD C4 5D 6E 7F A1 2B

1000:0020  81 15 4D ED 83 B7 8F 1A -89 7D B6 9C 3E 73 A2 21

执行前DS=0，AX=0，BX=0，那么执行下列汇编指令，完后AX 的值为（   ）

MOV AX,1000H

MOV DS,AX

MOV AX,[0]

A、 8589H        B、 8779H        C、 1581H        D、 8985H

42. 有以下几条指令（debug下的指令格式）：

    mov ax,1000

    mov ss,ax

    mov sp,0100

    mov ax,5CCA

    push ax

    指令“push ax”执行后，sp的值和修改的内存单元的地址是（  ）。

A. 0100H，1000H：0100H   B. 00feH，1000H：00feH  C. 0100，1000：0100  D. 98，1000：98

43. 如果将10000H~1FFFFH这段内存空间当做是栈空间，假设SS=1000H，则下列说法正确的是（）。

A.栈空的时候，SP的值为FFFEH     B.栈满的时候，SP的值为0

C.这段栈空间的大小为4KB       D.使用这段栈空间，有可能会出现栈越界

44. 给定段地址为1001h，则8086CPu可以寻址到物理地址为（  ）的内存单元。

A.0   B.20000H    C.10000H     D.20010H

45. CPU传递到地址总线上的地址是（  ）。

A.逻辑地址   B.偏移地址  C.物理地址   D.段地址

46. 关于8086CPU的几个寄存器，正确的说法是（  ）。

A.可将BX当成两个8位寄存器，在偏移地址范围为0~255时，可以用“mov ax,[bl]”来实现将内存中的数据读到ax中

B.可以用“byte ptr”实现将SI当成两个8位寄存器使用

C.可将AX、BX、CX、DX当成8个8位寄存器使用

D.AX、ah、al是不同的寄存器，指令“add al,bl”的执行不会影响AX的值

47. 下列与8086CPU寻址相关的说法，错误的是（  ）。

A.8086CPU有20根地址总线，它的寻址能力为1MB

B.一个物理地址可以对应多个段地址与偏移地址

C.因为段寄存器是16位，所以一个段最大为64KB

D.CPU内部有一个能合成20位地址的地址加法器

48. 以下指令执行后，SP的值为（  ）。

mov sp,0

push ss

A.0   B.0fffeh    C.2    D.内存ss：0处的数据的值

49. 用debug的e命令向b810：0010处写入数据，接着用d命令查看，发现b810：0010处并没有刚刚写入的数据，其原因是（  ）。

A.此处用于存储系统时间，一直在自动更新

B.debug存在延时，第二次查看即可看到用e命令写入的数据

C.此处处于ROM空间，不可以被改变

D.此处处于显存空间，当屏幕刷新时，此处的数据被更新了

50. 8086CPU中，如果某内存单元的物理地址为4FCE0，其段地址和偏移地址一定不会是（  ）。

A.4FC0：00E0 B.4CE0：2EE0 C.40CE：0F00 D.40C0：F0E0

51. 以下指令执行后，AX寄存器的值是（  ）。

mov ax,017ch

add al,0b4h

A.0130H      B.0230H      C.012FH      D.022FH

#### 答案与解析

1. 076B:0,和075A:0110是等价的，自己算算就知道了
2. 8086CPU的寻址范围为 `12340H` 到 `2233fH`。
3. 给定段地址 `101H`，8086CPU可以寻址到地址为 `10000H
4. 8位寄存器包括 `BL`。其他选项如 `AX`、`CS`、`DI` 都是16位寄存器。
5. 16位寄存器包括 `AX`。其他选项如 `BL`、`CH`、`DL` 都是8位寄存器。
6. 正确的说法是 `AX寄存器不能分为两个8位的寄存器`。其他选项不正确，因为 `BP` 和 `CS` 不能分为两个8位的寄存器，而 `PSW` 是一个特殊的寄存器，用于存放标志位，不是通用寄存器。
7. 错误的指令是 `MOV AL,1000`。因为 `AL` 是8位寄存器，不能直接加载16位的立即数。
8. 错误的指令是 `MOV BX,AL`。因为 `BX` 是16位寄存器，不能直接从8位寄存器 `AL` 获取数据。
9. 正确的指令是 `MOV AX，100`。
10. 执行这5条指令后，CPU会修改IP 6次。这是因为每次修改指令指针 `IP` 或代码段寄存器 `CS` 都会导致IP的修改。
11. 代码段寄存器是 `CS`。
12. 指令指针寄存器是 `IP`。
13. 在debug中，查看、修改CPU的寄存器内容是 `R` 命令。
14. 在debug中，查看内存中的内容是 `D` 命令。
15. 在debug中，修改内存中的内容是 `E` 命令。
16. 在debug中，执行CS、IP指向的内存单元处的指令是 `T` 命令。
17. 存储单元 `45A0：7CB9H` 的物理地址为 `4D6B9H`。这是通过将段地址 `45A0H` 乘以16（即左移4位）然后加上偏移地址 `7CB9H` 得到的。
18. 8086CPU中，任意时刻，CPU将 `CS、IP` 指向的内容当作指令来执行。
19. 这道题选c，t命令是单步中断，并不是一次只执行一个指令
20. 对于8086CPU，错误的指令是 `mov ds,0`。因为 `DS` 是段寄存器，不能直接用立即数进行赋值。
21. 执行这些指令后，寄存器 `AX` 的值为 `962AH`。首先，`mov ax, 0095h` 将 `AX` 设置为 `0095H`。接着，`mov ah, 95h` 将 `AH` 设置为 `95H`，但由于 `AH` 是 `AX` 的高8位，因此 `AX` 实际上变成了 `9595H`。最后，`add al, ah` 将 `AL`（即 `AX` 的低8位）和 `AH` 相加，结果为 `12AH`，最后 `AX` 的值为 962AH`。
22. 关于8086CPU，错误的说法是 `D. 在编程时，可将长度为1KB的一组地址连续，起始地址为32的倍数的内存单元当成栈空间来使用`。8086CPU的栈空间没有特定的起始地址要求，只要保证栈空间的连续性和正确设置栈指针即可。
23. `AX` 的初始值为 `00C5H`，执行 `add al, 85H` 后，`AX` 中的值是 `014AH`。这是因为 `AL`（`AX` 的低8位）原本是 `C5H`，加上 `85H` 后得到 `14AH`，`AH`（`AX` 的高8位）保持不变。
24. 关于汇编语言中“段”的概念，错误的说法是 `C. 一个段，不可以既是代码段，又是数据段`。在汇编语言中，一个段可以同时用作代码段和数据段。
25. 8086PC机一个段的最大长度为 `64KB`。
26. 选B，retf是利用了堆栈的，原因自己看书!
27. 设置 `10000H～1FFFFH` 的内存空间为栈段，初始状态栈是空的，此时，`SS`、`SP` 的值是 `SS=1000H`、`SP=FFFEH`。
28. 完成同指令 `XCHG AX, BX` 相同功能的指令或指令序列是 `D. MOV CX, AX; MOV AX, BX; MOV BX, CX`。这组指令首先将 `AX` 的值暂存到 `CX`，然后将 `AX` 和 `BX` 交换，最后将暂存的值从 `CX` 恢复到 `BX`。
29. 堆栈段段寄存器是 `SS`。
30. 堆栈指针寄存器是 `SP`。
31. 执行一次 `PUSH` 指令，`SP` 寄存器将 `减2`。
32. 执行一次 `POP` 指令，`SP` 寄存器将 `加2`。
33. 关于8086CPU堆栈，不正确的说法是 `B. 堆栈的长度是没有限制`。实际上，堆栈的长度是有限的，取决于可用内存的大小。
34. 下面指令正确的是 `A. POP AX`。
35. 8086系统中，一个堆栈最大可以设置为 `64KB`。
36. 选c，sp的值要比栈底大1，细节自己看书
37. 设 `SP` 初值为 `2000H`，执行指令 "PUSH AX" 后，`SP` 的值是 `1FFEH`。这是因为 `AX` 是一个字，所以 `PUSH AX` 将 `AX` 的值压入栈，`SP` 减少2。
38. 0029H
39. 8D29H
40. 1581H,1002H与1000:20等价，自己看看在哪个位置就行
41. 在 `debug` 中，用 "d 1000：0 0f" 查看内存，结果如下。执行前 `DS=0`，`AX=0`，`BX=0`，那么执行下列汇编指令后 `AX` 的值为 `8589H`。这是因为 `MOV AX, 1000H` 将 `AX` 设置为 `1000H`，然后 `MOV DS, AX` 将数据段寄存器 `DS` 设置为 `1000H`。接着 `MOV AX,[0]` 将 `[0]` 处的值加载到 `AX` 中，即 `8589H`。
42. 指令 "push ax" 执行后，`SP` 的值和修改的内存单元的地址是 `B. 00feH，1000H：00feH`。这是因为 `SP` 在执行 `push ax` 指令前为 `0100H`，执行后 `SP` 减1变为 `00feH`。修改的内存单元地址为 `1000H：00feH`，因为 `SS` 为 `1000H`，`SP` 为 `00feH`。
43. 如果将 `10000H～1FFFFH` 这段内存空间当做是栈空间，假设 `SS=1000H`，则正确的说法是  `D. 使用这段栈空间，有可能会出现栈越界`。
44. 给定段地址为 `1001h`，则8086CPU可以寻址到物理地址为 `10000H` 的内存单元。
45. CPU传递到地址总线上的地址是 `C. 物理地址`。
46. C.可将AX、BX、CX、DX当成8个8位寄存器使用
47. 下列与8086CPU寻址相关的说法，错误的是 `C. 因为段寄存器是16位，所以一个段最大为64KB`
48. 以下指令执行后，`SP` 的值为 `A. 0`。这是因为 `mov sp,0` 将 `SP` 设置为 `0`，然后 `push ss` 将 `SS` 的值压入栈，由于 `SP` 已经是 `0`，所以栈溢出，`SP` 保持不变。
49. 用 `debug` 的 `e` 命令向 `b810：0010` 处写入数据，接着用 `d` 命令查看，发现 `b810：0010` 处并没有刚刚写入的数据，其原因是 `D. 此处处于显存空间，当屏幕刷新时，此处的数据被更新了`。
50. 8086CPU中，如果某内存单元的物理地址为 `4FCE0`，其段地址和偏移地址一定不会是 `D. 40C0：F0E0`。这是因为 `40C0H` 不是 `4FCE0` 的有效段地址，且 `F0E0` 不是 `4FCE0` 的有效偏移地址。
51. 0230H，选B

### 第4~6章

1. 一个汇编源程序，从写出到最后被CPU执行，依次经历了哪几步？（  ）

A.编译、加载、连接、执行    B.加载、编译、连接、执行

C.连接、编译、加载、执行    D.编译、连接、加载、执行

2. 关于编译和连接，错误的说法是（  ）。

A.编译产生的*.obj文件不能在操作系统下直接运行

B.连接产生的*.exe文件里面没有伪指令

C.编译可以检查出语法错误

D.连接可以检查出逻辑错误

3. 源程序中有如下两个按先后顺序定义的段：

   ```assembly
    a segment 
    db 1,2,3,4,5,6,7,8 
    a ends 
   ```

   ```assembly
   b segment  
   db 1,2,3,4,5,6,7,8 
   b ends 
   ```

   如果a段中“1” 这个数据的物理地址是X，则b段中“1”这个数据的物理地址是（  ）。

   A. X   B. X+1   C. X+16    D. X+64
4. Debug加载程序后，假设PSP的段地址为SA，偏移地址为0，则程序的起始地址是（ ）。

A. SA×16H  B. SA×16   C. (SA+16H)×16H   D. (SA+16)×16

5. 下列关于汇编语言源程序的说法，错误的是（ ）

A. 一个汇编语言源程序从写出到执行需经过.编写.asm文件→将.asm文件编译为.obj文件→将.obj文件连接成.exe文件→.exe文件执行。

B. 在汇编语言源程序中，包含三种指令：汇编指令、伪指令、其他符号。

C. 在汇编语言源程序中，不由编译器执行的伪指令有对应的机器指令。

D. 在汇编语言源程序中，汇编指令是有对应机器码的指令，其所对应的机器指令由CPU执行。

    ``assembly       mov ax,4c00h       Int 21h       ``

CPU执行完这两条指令后，（  ）。

A. 返回到DOS   B. 返回到DEBUG   C. 返回到COMMOND    D. 前三个选项都不对

7. 下列说法正确的是（  ）。

A. 代码段中的信息都会被当做指令执行

B. CS：IP指向过的指令一定被CPU执行过

C. 用Debug的t命令，一次只能执行一条汇编指令

D. 通过“ASSUME”建立的段与段寄存器之间的关联是编译器要处理的

8. 执行下面的指令后，正确的结果是（  ）。

```assembly
mov al,198

and al, 01010011B 

or al,01010101B
```

A. al = 57   B. al = 57H   C. al = 42    D. al = 42H

9. 需要使用DS的指令是（  ）。

A. mov ax,[bp]  B. inc word ptr [bx]   C. add al,cl   D. and [bp],al

10. ```assembly
    data segment
    dd 1234h
    data ends
    ```

data段中的数据1234h在内存中的存储情况为（  ）。

A. 12 34 00 00   B. 34 12 00 00   C. 00 00 12 34   D. 00 00 34 12

11. BIOS存储在下列哪种硬件中？（  ）

A.   RAM  B.ROM  C.CPU  D.CMOS

12. 主板生产日期存储在下列哪种硬件中？（  ）

A.RAM  B.ROM  C.CPU  D.CMOS

13. 用 [di]、[bp]的方式访问内存时，8086CPU默认的段寄存器依次是（  ）。

A.ds、es   B.ds、ss  C.ss、ds  D.es、ss

14. 在debug中查看内存，显示如下：

073F：0000   CD 20 3E A7 00 EA FD FF-AD DE 4F 03 A3 01 8A 03

073F：0010   A3 01 17 03 A3 01 92 01-01 01 01 00 02 FF FF FF

073FH：0013H处的字型数据是（  ）。

A.007AH   B.03A3H  C.A303H   D.0317H

15. 对于8086CPU，正确的指令是（ ）。

A.mov ax,[bp+dx]    B.mov ax,ds.[bp+bx]

C.mov ax,ss：[si][di]  D.mov ax,cs.6[si]

16. 可以修改CX的指令是（  ）。

A.jmp  B.div  C.shl  D.jcxz

17. 关于标号，错误的说法是（  ）。

A.数据标号表示了内存单元的地址和长度。

B.后边加“：”的地址标号，只能在代码段中使用。

C.应用assume将指令中的数据标号所在的段，与一个段寄存器联系起来，这样，使用数据标号的指令，就可以从段寄存器中得到所用数据标号的段地址。

D.可以将一个标号集合存储在直接定址表中。

18. 关于PSP，错误的说法是（  ）。

A.这个程序设置(CS)*16+(IP)= PSP所在内存空间的首地址。

```assembly
assume cs：code
code segment 
start： mov ax,0
mov es,ax
mov word ptr es：[200h],0
mov es：[202h],ds
jmp dword ptr es：[200h]
code ends
end start
```

B.PSP共有256个字节。

C.DOS通过PSP来与其所加载的程序进行通信。

D.用debug加载一个其功能是设置(ds)=(cs)的程序后，即用a命令写且用T命令运行以下程序段：

```assembly
mov ax,ds
sub ax,10
mov ds,ax
```

之后用“d ds：0 ff”，可对PSP所在的内存空间进行查看。

19. 以下指令执行后，ax的值是（  ）。

```assembly
mov ax,6776h

add al,90h

add ah,90h
```

A.6806H  B.F806H   C.F706H    D.6706H

20. 以下指令执行后，al的值是多少？（  ）

```assembly
mov al,01100011b

and al,00111011b

or al,00111011b
```

A.00100011B   B.00111011B   C.01111011B   D.前三个选项都不对。

21. 以下程序运行时，源程序的指令中，CPU执行的第一条指令是？（  ）

```assembly
assume cs：a

codesg segment

mov ax,20h

mov ax,4c00h

int 21h

codesg ends

 

a segment

mov bx,30h

mov ax,4c00h

int 21h

a ends

b segment

mov bx,40h

mov ax,4c00h

int 21h

b ends

end
```

A.mov ax,20h   B.mov bx,30h  C.mov bx,40h    D.以上选项都不对

22. 对于8086CPU，正确的指令是（  ）。

A.INC WORD PTR DS：[0]      B.MOV ES：[0],DS：[0]

C.MOV AX,[BX+BP]         D.ADD CS,AX

23. 按照地址从低到高的顺序排列，双字型数据16在内存中如何存储？（  ）

A.00 00 10 00    B.00 00 00 10

C.00 10 00 00    D.10 00 00 00

24. 不可能出现在可执行文件中的是（  ）。

A.机器码    B.伪指令  C.源程序中定义的数据  D.JMP指令中的地址

25. 关于在程序中使用内存空间，不正确的说法是（  ）。

A.可以通过定义段的方式给程序分配安全的内存空间

B.DOS和应用程序一般不会使用0.200~0.2FF这段空间

C.使用安全的内存空间，不会影响DOS操作系统和其他合法程序的运行

D.使用MOV指令时，不用担心损坏系统数据

26. 以下指令中，可以被CPU执行的指令是（  ）。

A.SEGMENT   B.ASSUME   C.STI    D.END

27. CPU在读取指令时，实际读到的是什么？（  ）

A.伪指令和汇编指令所对应的字符串

B.用汇编语言写的源程序中的信息

C.由一系列二进制位组成的信息

D.汇编指令所对应的字符串

28. 对于8086CPU，错误的指令是（  ）。

A.mov ax,ds    B.push [bx]     C.inc [bx]     D.add bp,2

29. 对于8086CPU，下列关于段的说法，错误的是（  ）。

A.一个段的起始地址必须是16的整数倍

B.在源程序中定义一个段，在运行程序时，CPU不会因此定义而知道这个段的大小。

C.一块内存空间可以既是代码段，又是数据段。

D.CPU将某个段用做栈，是因为assume指令将其与SS寄存器相关联

30. （  ）的功能与“mov al,’d’”的 功能相同。

A.mov ax,’d’   B.mov al,’a’+3   C.mov al,’A’+3   D.or al,’d’

31. 关于汇编语言中的指令，正确的说法是（  ）。

A.汇编语言中的标号属于伪指令

B.汇编指令一定有对应的机器码

C.伪指令由编译器识别，编译器将其转化为对应的机器码

D.“+”一般会被编译成add指令

32. 以下程序运行时，“sub ax,masm”执行后，ax的值是（  ）。

assume cs：code

masm segment

dw 5 dup(‘a’,’b’,’c’)

masm ends

code segment

start： mov ax,code

```assembly
sub ax,masm

mov ax,4c00h

int 21h
```

code ends

end start

A.15    B.1    C.2   D.3

33. 关于debug的使用，错误的说法是（  ）。

A.Debug将程序加载到内存后，不执行任何命令前，IP的值一定为零

B.通过debug可以查看标志寄存器某些位的值

C.Debug将程序加载到内存后，不执行任何命令前，CX的值有可能是1024

D.T命令有可能一次执行一条以上的指令

34. 关于标号，下列说法正确的是（  ）。

A.   地址标号和数据标号都可以在jmp后使用

B.   后面带“：”的标号，用在代码段中是地址标号，用在数据段中是数据标号

C.   用在代码段中的数据标号只表示内存单元的地址

D.   在and与or指令中不可用地址标号

E.   前几个选项都不对

35. 汇编语言中不包括哪个元素？（  ）

A.汇编指令

B.机器指令

C.伪指令

D.“+”、“-”、“*”、“/”等符号

36. 对于编译、连接、运行，错误的说法是（  ）。

A.伪指令在编译的过程中被编译器执行了

B.使用masm编译器进行编译，只能生成目标文件

C.可执行文件中包含程序和描述信息

D.DOS提供的command程序可以将可执行文件中的程序加载进内存

37. 以下说法中，错误的是（  ）。

A.在用masm.exe编译的汇编语言的源程序中，end和ends都属于伪指令

B.在debug中调试一个程序，在用p命令依次执行程序中的“mov ax,4c00h”与

“int 21h”两条指令后，屏幕上显示“Program terminated normally”，可说明此

时程序已返回到DOS

 C.用于程序返回的相关指令是CPU来执行的

 D.对于程序返回，DOS提供了相应的中断例程

38. 用debug写几条指令：

```assembly
mov ax,20

mov ds,ax

mov ax,[1]
```

  之后查看内存，显示如下：

0：200 80 00 70 00 60 00 ……

接着用t命令执行这几条指令，“mov ax,[1]”执行后，AX的值是多少？（  ）

 A.7000H      B.0070H      C.1            D.0080H

39. 以下指令执行后，AX的值是多少？（  ）

    mov ax,20

    mov es,ax

    mov byte ptr es：[0],80h

    mov byte ptr es：[1],00h

    mov byte ptr es：[2],70h

    mov byte ptr es：[3],00h
    mov ax,es：[1]

  A.7000H           B.0070H           C.1            D.0080H

40. 汇编语言源程序中的“dw”、“db”、“dd”等指令属于（  ）。

    A.汇编指令        B.伪指令     C.机器指令        D.标号
41. 对于程序的执行过程，错误的说法是（  ）。

    A.通过command将程序加载进内存后，command将根据可执行文件中的描述信息，设置CS.IP指向第一条要执行的指令

    B.通过debug将程序加载进内存后，用r命令查看CX的值，可看到与程序的长度相关的信息

    C.通过debug将程序加载进内存后，DS指向程序的数据段，CS指向程序的代码段

    D.在源程序中用end指令，可以决定程序加载后IP寄存器的值
42. 下列对于程序段前缀（PSP）的描述，错误的是（  ）。

A.PSP占256个字节的地址空间

B.DOS通过PSP与被加载的程序通信

C.用debug将程序载入内存后，PSP与代码段的段地址一致，偏移地址相差100h

D.用debug将程序载入内存后，可用“d ds：0 ff”查看PSP的全部内容

43. 下面汇编语言源程序中的指令可以通过编译的是（  ）。

A. mov al,2000  B. push [0]  C. add al,100h  D. mov dx,1000h

44. 下列说法正确的是（  ）。

A. Push、pop指令通过修改ss：sp的值来操作栈中的数据

B. 栈空时，ss：sp指向栈底

C. 栈满以后，如果继续向其中压入数据，会覆盖栈顶之后的高地址内存单元

D. 栈满以后，如果继续向其中压入数据，不一定会覆盖其地址比栈顶的地址更低的内存单元

45. 其所传送的数据在内存中的指令是（  ）。

A. pop ax  B. mov ax,bx  C. mov ax,0  D. in al,20h

46. 以下程序加载后，在执行前，(ds)=0a21h。对于此时的寄存器与程序的相关情况，错误的说法是（  ）。

```assembly
assume cs：code,ds：data

  data segment

  db ’1975’

  data ends

code segment

dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah

mov ax,0

mov bx,0

 

mov cx,8

s： add ax,cs：[bx]

add bx,2

loop s

  mov ax,4c00h

  int 21h

 

code ends

end
```

A. 程序的起始段地址为0a31h

B. (cs)=0a31h，(ip)=0

C. ds的值不是data段的段地址

D. “mov ax,0”的机器码的内存地址是0a31H：0020H

47. masm和debug默认的进制分别是（  ）。

A.十六进制和十进制    B.十进制和二进制

C.十进制和十六进制    D.二进制和十六进制

48. 补全这段程序，使其执行后，(bx)=3。（  ）

mov bx,1

mov cx,___

loop s1

mov bx,2

s1： inc bx

A. 0   B. 1  C. 2  D. 3

#### 答案与解析

1. D.编译、连接、加载、执行
2. D.连接可以检查出逻辑错误
3. C. X+16
4. D. (SA+16)×16
5. C. 在汇编语言源程序中，不由编译器执行的伪指令有对应的机器指令
6. A. 返回到DOS
7. C. 用Debug的t命令，一次只能执行一条汇编指令
8. B. al = 57H
9. B。bp这个寄存器对应的段寄存器不是DS
10. B. 34 12 00 00
11. B.ROM
12. B。ROM
13. B.ds、ss
14. B.03A3H
15. A.mov ax,[bp+dx]
16. C.shl
17. C.应用assume将指令中的数据标号所在的段，与一个段寄存器联系起来，这样，使用数据标号的指令，就可以从段寄存器中得到所用数据标号的段地址。
18. A.这个程序设置(CS)16+(IP)= PSP所在内存空间的首地址。
19. B.F806H
20. B.00111011B
21. CPU执行的第一条指令是 mov ax,20h1.
22. 对于8086CPU，正确的指令是 INC WORD PTR DS:[0]
23. 双字型数据16在内存中的存储方式是 00 00 00 10
24. 不可能出现在可执行文件中的是 伪指令
25. 关于在程序中使用内存空间，不正确的说法是 使用MOV指令时，不用担心损坏系统数据
26. 以下指令中，可以被CPU执行的指令是 STI
27. CPU在读取指令时，实际读到的是 由一系列二进制位组成的信息
28. 对于8086CPU，错误的指令是 mov ax,ds
29. 对于8086CPU，下列关于段的说法，错误的是 CPU将某个段用做栈，是因为assume指令将其与SS寄存器相关联
30. 功能与“mov al,’d’”的 功能相同的是 mov al,’a’+310
31. 关于汇编语言中的指令，正确的说法是 汇编指令一定有对应的机器码
32. 以下程序运行时，“sub ax,masm”执行后，ax的值是15
33. 关于debug的使用，错误的说法是 Debug将程序加载到内存后，不执行任何命令前，IP的值一定为零
34. 关于标号，下列说法正确的是 前几个选项都不对
35. 汇编语言中不包括哪个元素？答案是 “+”、“-”、“*”、“/”等符号
36. 对于编译、连接、运行，错误的说法是 伪指令在编译的过程中被编译器执行了
37. 以下说法中，错误的是 在用masm.exe编译的汇编语言的源程序中，end和ends都属于伪指令
38. 用debug写几条指令后，“mov ax,1”执行后，AX的值是 0070H
39. 以下指令执行后，AX的值是 0080H
40. 汇编语言源程序中的“dw”、“db”、“dd”等指令属于 伪指令
41. 通过debug将程序加载进内存后，DS指向程序的数据段，CS指向程序的代码段（DS指向程序的psp，执行装填指令才有正确的段地址）
42. 下列对于程序段前缀（PSP）的描述，错误的是 用debug将程序载入内存后，PSP与代码段的段地址一致，偏移地址相差100h
43. 下面汇编语言源程序中的指令可以通过编译的是D
44. C. 栈满以后，如果继续向其中压入数据，会覆盖栈顶之后的高地址内存单元
45. 其所传送的数据在内存中的指令是 mov ax,025.
46. D. “mov ax,0”的机器码的内存地址是0a31H：0020H
47. masm和debug默认的进制分别是 十进制和十六进制
48. 补全这段程序，使其执行后，(bx)=3的答案是 2

### 第7-8章（寻址方式）

1. 以下寻址方式中，属于相对基址变址寻址的是（  ）。

A. [bx+si+idata]    B. [bx+di]    C. [bp+si]    D. [bx]

2. 可在基址变址寻址或寄存器间接寻址中，用作偏移地址寄存器的是（  ）。

A. ax，bx，cx，dx    B. ds，es，cs，ss

C. sp，bp，ip，bx    D. si，di，bp，bx

3. 用“dd 5 dup (1,2,3,4)”说明的数据，在程序运行时，共占用（  ）个字节。

A. 4  B. 20  C. 40  D. 80

4. 对于8086CPU，错误的指令是（  ）。

A. mov ax,[bp+si]  B. mov ax,[bx]  C. mov ax,2[si]  D. mov al,[dx]

5. 下列寻址方式属于基址变址寻址的是（  ）。

A. [di]  B. [bx+idata]  C. [bx+di]  D. [bp+di+idata]

6. “mov word ptr [bx+si],1”采用的寻址方式为（  ）。

A.寄存器间接寻址 B.寄存器相对寻址 C.基址变址寻址     D.相对基址变址寻址

7. 用div指令进行除法运算，除数为16位时，余数存放在（  ）中。

A.AX   B.AH  C.AL   D.DX

8. 若AX=1000H，CL=90H，则执行指令DIV CL之后，AX=（  ）。

A.401CH    B.001CH   C.0040H   D.1C40H

9. 以下关于8086CPU的div指令的说法，错误的是（  ）。

A.被除数可以放在寄存器中，也可以放在内存单元中。

B.若结果的商大于al或ax所能存储的最大值，将引发CPU内部的除法溢出错误。

C.可以重写0号中断处理程序，使得程序可以处理除法溢出的情况。

D.可使用div指令编写一个计算32位被除数/8位除数的子程序。

10. 执行以下指令后，AX的值是（  ）。

```assembly
mov al,96h  

mov bl,12h

mul bl
```

A. 1152h 　　　　  B. 0a8ch

C. 0a82h 　　　   D. 0f88ch

11. 以下指令执行后，AX的值是多少？（  ）

```assembly
mov ah,1
mov al,10h
mov bl,2
mul bl
```

  A.0220H      B.2000H      C.0020H       D.0120H

12. 下列指令中（  ）可以实现，将AX寄存器中的最低3位清0

A、 OR  AX,0FFF8H

B、 AND AX,0FFF8H

C、 AND AX,0FFF7H

D、 AND AX,0FFFBH

13. 下列指令中（  ）可以实现，将AX寄存器中的D3和D7位置1

A、 XOR  AX,08H

B、 OR AX,08H

C、 OR AX,88H

D、 XOR AX,88H

14. 下列指令中（  ）可以实现，将AX寄存器中的最高3位取反

A、 NOT AX

B、 AND AX,1FFFH

C、 XOR  AX,0E000H

D、 OR  AX,0E000H

15. 数据段中有如下定义

  X1 DB 1,2,3,4,5,6,7,8

  X2  DW  1,2,3,4,5,6,7,8

以下指令中错误的是（   ）

A、 MOV   X1,100

B、 MOV  AX,X1

C、 MOV AX,X2

D、 MOV X2,100

16. 数据段中有如下定义

  X1 DB 1,2,3,4,5,6,7,8

  X2  DW 1,2,3,4,5,6,7,8

以下指令中正确的是（   ）

A、 MOV   X1,1000

B、 MOV  AX,X1

C、 MOV AH,X2

D、 MOV X2,1000

17. 数据段中有如下定义

  X1 DB 1,2,3,4,5,6,7,8,9,10

  X2 DW 100

执行完下面的程序段之后，DX的值是（   ）。

   MOV  CX,10

   MOV  DX,X2

S:  MOV  BX,CX

   MOV  AL,X1[BX]

   MOV  AH,0

   ADD  DX,AX

   DEC  CX

   LOOP  S

A、 124      B、 224      C、 155      D、 255

18. 下列指令序列不能够实现把内存地址0:202h中的字节数据送入al功能的是______•

A、 mov ax,0

mov ds,ax

mov bx,202h

mov al,[bx]

B、 mov ax,0

mov ds,ax

mov bp,202h

mov al,[bp]

C、 mov ax,0

mov ds,ax

mov bx,200h

mov al,[bx+2]

D、 mov ax,0

mov ds,ax

mov bp,200h

mov al,ds:[bp+2]

19. 下列指令中，正确的是（ ）

A、 MOV AX,[BX+BP]          B、MOV AX,[BX+SI]

C、 MOV  AL,[SI+DI]      D、 MOV  AL,[SI+DX]

20. 下列指令中，错误的是（ ）

A、 MOV AX,[BX+SI]      B、 MOV AX,[BX+DI]

C、 MOV  AL,[SI+DI]      D、 MOV  AL,[SI+BP]

21. 下列指令中，正确的是（  ）

A、 MOV DS:[BP+BX],AH       B、 ADD  [BX],100

C、 MOV  [SI],AL         D、 MOV  [SI],100

22. 下列指令中，错误的是（  ）

A、 MOV DS:[BP+SI],AH        B、ADD  WORD PTR [BX],100

C、 MOV  [SI],AL              D、 MOV  [SI],100

23. 下列指令中，错误的是（  ）

A.MOV DS:[BP+SI],AH          B.ADD  WORD PTR [SI],100

C.MOV  [SI],AL                 D.MOV  [SI],[DI]

24. 下列哪个程序段可以实现将987*6 ？ （  ）

A、 MOV  AX,987

MOV BX,6

MUL  AX,BX

B、 MOV  AX,987

MOV BX,6

MUL  BX

C、 MOV  AX,987

MOV BL,6

MUL  BL

D、 MOV  AL,6

MOV BX,987

MUL  BX

25. 下列哪个程序段可以实现将987/30 ？ （  ）

A、 MOV  AX,987

MOV BX,30

DIV  BX

B、 MOV  DX,987

MOV BL,30

DIV  BL

C、 MOV  AX,987

MOV BL,30

DIV  BL

D、 以上选项都不对

26. 执行下列程序段

MOV  AX,87

MOV BX,6

MUL  BX

 去 （  ）寄存器查看结果

A、 AX       B、BX        C、DX        D、 DX存放结果高16位，AX存放结果低16位

27. 执行下列程序段

MOV  AX,87

MOV BL,6

MUL  BL

 去 （  ）寄存器查看结果

A、 AX

B、 BX

C、 AL

D、 DX存放结果高16位，AX存放结果低16位

28. 数据段中有如下定义：

```assembly
    DATA1 DB  1,2,3,4
   DB  5,6,7,8

    DB  9,10,11,12

    DB  1,2,3,4
```

执行下列程序段

```assembly
   MOV  BX,0

   MOV SI,0

   MOV CX,4

   MOV AL,0

S:  ADD  AL,DATA1[BX][SI]

   INC SI

   ADD  BX,4

   LOOP  S
```

 AL寄存器的结果是（   ）

A、 10       B、 16       C、 24       D、 22

29. 数据段中有如下定义：

```assembly
     DATA1 DB  1,2,3,4
    DB  5,6,7,8

    DB  9,10,11,12

    DB  1,2,3,4
```

执行下列程序段

```assembly
   MOV  BX,0
   MOV SI,0
   MOV CX,4
   MOV AL,0
   S:  ADD  AL,DATA1[BX][SI]
   INC SI
   INC BX
   LOOP  S
```

 AL寄存器的结果是（   ）

A、 10       B、 16       C、 24       D、 22

30. 数据段中有如下定义：

```assembly
     DATA1 DB  1,2,3,4
    DB  5,6,7,8

    DB  9,10,11,12

    DB  1,2,3,4
```

执行下列程序段

```assembly
   MOV  BX,0

   MOV SI,0

   MOV CX,4

   MOV AL,0

S:  ADD  AL,DATA1[BX+SI]

   ADD  AL,DATA1[BX+4+SI]

   INC SI
   LOOP  S
```

 AL寄存器的结果是（   ）

A、 10       B、 16       C、 52       D、 36

31. 有如下定义，说法正确的是（  ）。

 X DW  5  DUP (1,2,3)

A、 总共定义了15个字节          B、 总共定义了3个字节

C、 总共定义了5个字节       D、 总共定义了30个字节

32. 有如下定义，说法正确的是（  ）。

 X DB  3  DUP (1,2 DUP(3))

A、 相当于  X  DB  1，2，3

B、 相当于   X  DB  1，2，3，1，2，3，1，2，3

C、 相当于  X  DB  1，3，3，1，3，3，1，3，3

D、相当于  X  DB  1，2，2，1，2，2，1，2，2

33. 有如下定义，说法正确的是（  ）。

 X DW  5  DUP (1,3 dup（2）)

A、 总共定义了10个字节          B、 总共定义了20个字节

C、 总共定义了30个字节           D、 总共定义了40个字节

#### 答案与解析

1. A. [bx+si+idata]
2. D. si，di，bp，bx
3. D. 80,dd占4个字节，一共有20个数字，因此4*20=80
4. D. dx不作为寻址的寄存器
5. C. [bp+di]
6. C.基址变址寻址
7. D.DX,顺带一提，商存在AX寄存器
8. B.001CH
9. A.被除数只能放寄存器，除数可以放reg和内存单元，具体细节可以看书上8.7节
10. 这题选B，0a8ch，十六进制乘法不懂可以自己上网搜索
11. D.0120H
12. B、 AND AX,0FFF8H
13. C、 OR AX,88H
14. C、 XOR AX,0E000H,将指定位取反优先考虑异或，这是个做题技巧捏
15. B、 X2是一个8位字单元，不能直接送到16位的AX寄存器
16. C
17. B、 224
18. B、 bp寄存器对应的段寄存器是ss，只设置ds是没用的
19. B、MOV AX,[BX+SI]
20. C、 MOV AL,[SI+DI]
21. B、 ADD [BX],100
22. D、 MOV [SI],100
23. D.MOV [SI],[DI].si和di不能同时出现，bp和bx也是
24. B、
25. C、 MOV AX,987 MOV BL,30 DIV BL
26. D、 DX存放结果高16位，AX存放结果低16位
27. D、 AX
28. C、 24
29. B、 16
30. D、 36
31. D、 总共定义了30个字节
32. C、 相当于 X DB 1，3，3，1，3，3，1，3，3
33. D、 总共定义了40个字节

### 第9-10章

1. CPU在执行“call标号” 时，相当于执行（  ）。

   A.   push IP ； jmp far ptr 标号

   B.   push  CS ； push IP ； jmp far ptr 标号

   C. push IP ； jmp near ptr 标号

   D. push  CS ； push IP ； jmp near ptr 标号
2. 使用call和ret指令，我们可以实现汇编语言编程中的模块化设计。以下描述中错误的是（  ）。

   A. 可以用call和ret指令实现多个子程序。

   B. 可以通过多个相互联系、功能独立的子程序来解决一个复杂的问题。

   C. 对于通用的子程序，最好加上详细的注释。

   D. 用汇编语言进行程序设计，子程序一定要用call和ret来实现。
3. 以下程序执行后，AX的值为（  ）。

```assembly
 MOV AX,4
 CALL S

 NOP
 S：
  MOV AX,OFFSET S

 MOV BP,SP

 SUB AX,[BP]
```

A.0    B.1   C.2    D.3

4. 对于根据位移进行跳转的jmp指令，跳转的位移是在什么时候计算的？（ ）

A. 编译  B. 连接  C. 运行  D. 编译或运行

5. 可修改cs和ip的指令是（  ）。

A. jmp ax  B. jmp far ptr s  C. loop  D. ret

6. “jmp word ptr [bx]”进行的是（  ）。

A.   段内近转移   B.段间近转移 C.段内短转移 D.段间短转移

7. “jmp word ptr [bx]”修改寄存器是（  ）。

A.IP B. BP     C.CS D.CS和IP

8. 哪个指令的跳转范围可以与其它三个不同？（  ）

A.jmp   B.jcxz   C.loop   D.je

9. 下列说法正确的是（  ）。

A.   iret指令可以描述为：

```assembly
 popf
 pop cs
 pop ip
```

B.   mov al,1

add al,0ffh

上面两条指令执行后，(AX)=0

C.   用debug进行调试时，用p命令可以一次执行多条汇编指令

D.   call指令不能通过位移进行跳转

10. 关于loop指令，错误的说法是（  ）。

    A.loop指令的跳转范围是-128~127

    B.CX=10时，执行loop指令，IP的值一定减小

    C.CX=0时，执行loop指令后，CX=0ffffh

    D.CX=1时，执行loop指令，IP的值不变
11. 假设sp=0010h，则执行哪条指令，sp的值会减小？（  ）

A.IRET   B.JMP 标号   C.RETF   D.CALL 标号

12. 在debug中，用“d 1000：0”查看内存，显示如下.

1000：0000  69 76 65 20 25 63 20 61-6E 64 20 70 72 65 73 73

1000：0010  20 3C 45 4E 54 45 52 3E-0A 00 6B 00 41 62 6F 75

1000：0020  74 20 74 6F 20 67 65 6E-65 72 61 74 65 20 2E 45

接着，即写且执行以下指令：

mov ax,1000

mov ds,ax

jmp DWORD PTR [2]

之后，cs：ip的值依次是（  ）。

A.6325：2065  B.6520：2563  C.2065：7669    D.6520：2567

13. 关于转移指令，错误的说法是（  ）。

A.进行段内短转移时，jmp指令对应的机器码中没有转移的目的地址。

B.进行段间转移时，jmp指令对应的机器码中有转移的目的地址。

C.进行段内短转移时，IP的修改范围是0~255。

D.loop指令也是转移指令。

14. 读取，执行哪条指令CPU会修改两次IP？（  ）

    A.push   B.pushf   C.ret    D.mov
15. 在debug中用t命令执行下列指令，可观察到的现象是（  ）。

```assembly
内存地址     汇编指令
 076e：0      mov ax,5

 076e：3      call ax

 076e：5      inc ax

 076e：6      mov bp,sp

 076e：8      jmp word ptr [bp]
```

 A.循环执行mov ax,5   和call ax

B.循环执行call ax到jmp word ptr [bp]

C.循环执行inc ax到jmp word ptr [bp]

D.ss：bp指向处的数据未知，因而跳转到未知内存处，结果不可预测

16. 用一条指令补全程序，使这个程序可以返回。（  ）
    assume cs：code
    data segment
    dd 4 dup (0)
    data ends
    code segment
    s：
    mov ax,4c00h
    int 21h
    code ends

    assume cs：a
    a segment
    start：
    a ends
    end start

A.jmp s    B.loop s   C.jmp far ptr s    D.jmp near ptr s

17. 读取执行下面的指令之后，CPU总共修改了几次IP的值？（  ）

SUB AX,AX

RETF

A.1   B.2   C.3    D.4

18. 8086CPU读取、执行指令的过程是（  ）。

①从CS：IP指向的内存空间读取指令，将指令放入指令缓冲器

②执行指令，转到步骤①

③IP指向下一条指令

A.① ②

B.① ③ ②

C.若指令是转移指令，过程为① ③ ②，不是则过程为① ②

D.若指令是转移指令，过程为① ②，不是则过程为① ③ ②

19. 有以下定义

DATA SEGMENT

 X1 DB 5 DUP (1，2，3)

 X2 DW 1

 X3 DW 1000H

DATA ENDS

执行下面的程序段后，CX的值为（  ）

  MOV  AX,DATA

  MOV  DS,AX

  MOV  CX,OFFSET X3

A、 15

B、 16

C、 17

D、 18

20. 用Debug查看内存，结果如下：

2000:1000 04 05 60 BE 00 06 00 00 00 ……

则此时，CPU执行指令：

mov ax,2000H

mov es,ax

jmp dword ptr es:[1002H]

后，说法正确的是（   ）

A、 (CS)=2000H，(IP)=1002h

B、 (CS)=BE60H，(IP)=0600H

C、 (CS)=60BEH，(IP)=0006H

D、 (CS)=0600H，(IP)=BE60H

21. 有以下定义

DATA SEGMENT

 X1 DB 5 DUP (1，2，3)

 X2 DW 1

 X3 DW 1000H

DATA ENDS

执行下面的程序段后，CX的值为（  ）

  MOV  AX,DATA

  MOV  DS,AX

  MOV  BX,OFFSET X3

  MOV  CX,[BX]

A、 18

B、 17

C、 1

D、 1000H

22. 关于指令 JMP SHORT 标号，说法正确的是

A、 执行该指令，修改CS和IP一次

B、 执行该指令，修改IP一次

C、 执行该指令，修改IP两次

D、 执行该指令，修改IP三次

23. 关于指令 JMP SHORT 标号，说法正确的是

A、 执行该指令，（IP）=（IP）+8位位移量

B、 执行该指令，（IP）=（IP）+16位位移量

C、 执行该指令，（IP）=（IP）+标号所在段中的偏移地址

D、 执行该指令，（IP）=标号所在段中的偏移地址

24. 关于指令 JMP NEAR PTR 标号，说法正确的是

A、 执行该指令，（IP）=（IP）+8位位移量

B、 执行该指令，（IP）=（IP）+16位位移量

C、 执行该指令，（IP）=（IP）+标号所在段中的偏移地址

D、 执行该指令，（IP）=标号所在段中的偏移地址

25. 关于指令 JMP FAR PTR 标号，说法正确的是

A、 执行该指令，（IP）=（IP）+8位位移量

B、 执行该指令，（IP）=（IP）+16位位移量

C、 执行该指令，（IP）=（IP）+标号所在段中的偏移地址

D、 执行该指令，（IP）=标号所在段中的偏移地址

26. 下列指令中，没有修改CS的是（   ）

A、 JMP  AX

B、 JMP  FAR PTR  S1

C、 JMP DWORD PTR  DS:[0]

D、 JMP DWORD PTR [BX]

27. 下列指令中，同时修改CS和IP的是（   ）

A、 JMP  AX

B、 JMP  NEAR PTR  S1

C、 JMP WORD PTR  DS:[0]

D、 JMP DWORD PTR [BX]

#### 答案与解析

1. C.call只改变IP的值
2. D. 用汇编语言进行程序设计，子程序一定要用call和ret来实现。这个不一定，你自己用call本质上就是使用了jmp和push指令，你直接用jmp，push和call是在功能上是等价的
3. A. 0
4. A. 编译
5. B. jmp far ptr s
6. A. 段内近转移
7. A.段内转移只修改IP
8. A. jmp.这里你必须知道一个信息，所有有条件转移的指令都是短转移，jmp是无条件的，因此只有他最与众不同
9. A. iret指令可以描述为：popf；pop cs；pop ip
10. C. CX=0时，执行loop指令后，CX=0ffffh
11. D. CALL 标号
12. A. 6325:2065
13. C. 进行段内短转移时，IP的修改范围是0~255
14. C. ret
15. D. ss：bp指向处的数据未知，因而跳转到未知内存处，结果不可预测
16. A. jmp s
17. C. 3次.Sub修改一次，RETF修改两次
18. B. ① ③ ②
19. B. 16
20. D. (CS)=BE60H，(IP)=0600H
21. D.1000H
22. B. 执行该指令，修改IP一次1
23. A. 执行该指令，（IP）=（IP）+8位位移量
24. B. 执行该指令，（IP）=（IP）+16位位移量
25. D. 执行该指令，（IP）=标号所在段中的偏移地址
26. A. JMP AX
27. D. JMP DWORD PTR [BX]

### 第11章

1. 以下指令执行后，of和cf的值是（  ）

   ```assembly
      mov ax,0
      push ax
      popf
      mov ax,0ffffh
      inc ax 
   ```

   A. of=0，cf=0

   B. of=1，cf=0

   C. of=0，cf=1

   D. of=1，cf=1
2. 以下指令执行后，sf、cf、zf、of的值分别是（  ）。
   ``mov ax,0ea04h  sub ax,4ae0h  ``

   A. 0，1，0，1

   B. 1，1，0，0

   C. 1，0，0，0

   D. 1，0，1，0
3. 可以改变标志寄存器的值的指令是（  ）。
   A.PUSHF   B.MOV AX,AX     C.SHL AX,CL   D.JCXZ
4. 可改变SF和ZF的值的指令是（  ）。
   A.JE NEXT   B.IN AL,20H   C.PUAH AX   D.SHL AX,1
5. 不会影响标志寄存器的值的指令是（  ）。
   A.adc ax,bx   B.cmp cx,ax   C.inc ax    D.jmp word ptr [bx]
6. 可使if=1的指令是（  ）。

   A.sti   B.cld   C.std   D.shr
7. ```assembly
   mov al,62h
   add al,63h
   ```

   这两条指令执行后，cf\of的值是（  ）。

   A. cf=0，of=0 B. cf=0，of=1  C. cf=1，of=0  D. cf=1，of=1
8. 下面对标志位的描述，正确的是（  ）。

   A. 可以用栈指令改变标志位的值

   B. Cmp、pushf指令都可能会对标志位的值产生影响

   C. 可以通过判断cmp指令执行后的sf位是否为1知道两个数的大小

   D. 传送指令.移位指令对标志位的值无影响
9. 执行JNB指令时，（  ），则进行跳转。

   A.CF=1且ZF=1         B.CF=0或ZF=1    C.CF=0或ZF=0 D.CF=0
10. 下面的程序执行后，PF、SF、CF、OF的值分别为（  ）。

    MOV AX,0FF80H

    ADD AL,0F0H

    A.PF=1 SF=1 CF=1 OF=1      B.PF=0 SF=1 CF=1 OF=1

    C.PF=0 SF=0 CF=1 OF=1      D.PF=1 SF=0 CF=0 OF=0
11. 下面的程序执行后，PF、SF、CF、OF、ZF的值分别为（  ）。

    MOV AX,0FF80H

    XOR AX,AX

    A.PF=1 SF=1 CF=1 OF=1 ZF=0      B.PF=0 SF=1 CF=1 OF=1 ZF=0

    C.PF=0 SF=0 CF=1 OF=1 ZF=1      D.PF=1 SF=0 CF=0 OF=0 ZF=1
12. 下列与标志寄存器相关的说法，错误的是（  ）。

    A.标志寄存器可以通过栈指令访问

    B.当al=0ffh，执行“inc al”，将影响cf的值

    C.算数运算指令不会影响df标志位

    D.根据无符号数的比较结果进行转移的条件转移指令，检测的是zf.cf的值
13. 对于标志寄存器相关位的描述，错误的是（ ）。

    A.   mov al,1

    add al,127

    结果为128（80H）,SF为1，超出了-128~127的范围，所以OF为1，这两条指令执行后，OF=1，发生溢出；虽然逻辑结果为正，但SF却为1

    B.   mov al,1

        add al,0ffh

    结果为100h，保留00H,CF=1，正数1和负数-1相加，不会溢出，OF=0。这两条指令执行后，OF=0，CF=1

    C.“inc ax”不影响标志寄存器的CF位

    D.   S：mov ax,8f00h

        cmp ax,5 ；

    标志寄存器不改变，保留原值，执行中断子程序，执行中间可能会影响标志寄存器这段程序执行过程中，SF一直为1
14. 下列指令，一定不会使标志寄存器发生变化的是（ ）。

    A.int 21h      B.jmp ax  C.cmp ax,bx  D.sub ax,ax
15. 如果AL=75H，则执行ADD AL,0F0H之后，OF、CF的值是（  ）。

    A.OF=1，CF=0   B.OF=0，CF=0  C.OF=0，CF=1    D.OF=1，CF=1
16. 以下哪个选项中的指令执行后，zf=1，pf=1？（  ）

    A.mov ax,1   B.mov ax,1   C.mov ax,1    D.mov ax,1

    add ax,2    and ax,0    sub ax,2     or ax,0
17. 以下哪个选项中的指令执行后，cf=1,of=1？（  ）

    A.mov al,98      add al,99
    B.mov al,0f0H  add al,88H
    C.mov al,0f0H  add al,78H
    D.mov al,68H   add al,1



18. 关于串传送指令，错误的说法是（  ）。

    A.只用一条movsb指令，即可以将一个内存单元里的数据传送到另一个内存单元

    B.movsb指令执行后，SI与DI的值可能会增加，也可能会减小

    C.传送可以以字节为单位进行，也可以以字为单位进行

    D.如果在执行“movsb”之前，CX的值是10，“movsb”将重复执行10次
19. 关于串传送指令，正确的说法是（  ）。

    A. movsb指令，将一个ds:di指向内存单元里的字节传送到es:si内存单元中

    B. 如果DF=1，则movsb指令执行后，SI会增加1

    C.传送可以只能以字节为单位进行

    D. rep和 movsb配合使用，可以传送一批数据。
20. 对于8086CPU的标志寄存器，下列说法错误的是（  ）。

    A.标志寄存器是16位的

    B.无法通过一条汇编指令将标志寄存器的所有位都更新

    C.这个寄存器中的有些位没有任何含义

    D.cmp指令能够改变标志寄存器的值

#### 答案与解析

1. D. of=1，cf=1
2. C. 1，0，0，0
3. A.PUSHF
4. D.SHL AX,1
5. D.jmp word ptr [bx]1
6. A.sti
7. C. cf=1，of=0
8. A. 可以用栈指令改变标志位的值
9. B.JNB大于或等于转移.
10. B.PF=0 SF=1 CF=1 OF=1
11. D.PF=1 SF=0 CF=0 OF=0 ZF=1
12. B.当al=0ffh，执行“inc al”，将影响cf的值
13. D
14. B.jmp ax
15. D.OF=1，CF=1
16. B.mov ax,1 and ax,0
17. B.mov al,0f0H add al,88H
18. A.只用一条movsb指令，即可以将一个内存单元里的数据传送到另一个内存单元
19. D. rep和 movsb配合使用，可以传送一批数据。
20. B.无法通过一条汇编指令将标志寄存器的所有位都更新.这个自己看书，在第11章有

### 第12章及之后

1. 中断向量表中存放的是（  ）。

A. 中断类型码      B. 中断处理程序的入口地址

C. 中断处理程序     D. 断点地址

2. 中断向量占（  ）字节。

A. 1      B. 2        C. 3     D. 4

3. 使用call和ret指令，我们可以实现汇编语言编程中的模块化设计。以下描述中错误的是（  ）。

   A. 可以用call和ret指令实现多个子程序。

   B. 可以通过多个相互联系.功能独立的子程序来解决一个复杂的问题。

   C. 对于通用的子程序，最好加上详细的注释。

   D. 用汇编语言进行程序设计，子程序一定要用call和ret来实现。
4. 以下指令执行后，al和cf的值分别是（  ）。

```assembly
mov al,00000001B
mov cx,109h
shl al,cl
```

A. 29 ，1   B. 29 ，0   C. 0，1   D. 0，0

5. 已知（AX）=2，则能实现（AX）=（AX）*8的程序段是（  ）。

A.SHL AX,3      B.SHR AX,3

C.MOV CL,3      D.MOV CL,3

SHL AX,CL       SHR AX,CL

6. 关于shl与shr，正确的说法是（  ）。

A.shl用0补充最高位。

B.shr将一个寄存器或内存单元中的数据向左移动。

C.移出的bit的值是0，shl与shr不影响CF。

D.shr用0补充最高位。

7. 其逻辑不是实现 (ax)=(ax)*10的程序段是（  ）。

A. shl ax,1

mov bx,ax

mov cl,2

shl ax,cl

add ax,bx

B. mov bx,ax

shl ax,1

shl bx,1

shl bx,1

add ax,ax

add ax,bx

C. mov bx,ax

mov cl,3

shl ax,cl

shl bx,1

add ax,bx

D. mov cl,3

shl ax,cl

mov bx,ax

mov cl,2

shr bx,cl

add ax,bx

8. 现在想要判断AL的值是否是某个正整数的2^n（n是正整数）次方，若al=10000110b，那么至少需要移位几位，通过cf的值可判断出结果？（  ）

A.1           B.2           C.3           D.4

9. 中断向量表中存放的是（ ）。

A.中断类型码  B.断点地址   C.中断处理程序  D.中断处理程序的入口地址

10. 可以实现将ax的值增大2倍的是（  ）。

A. mul 2   B. mul ax,2   C. shl ax,1  D. shr ax,1

11. 对于8086CPU，正确的指令是（  ）。

A. inc cx,1    B. shl ax,2   C. and [bp],al    D. mov [bx][bp],ax

12. 对于在debug中使用t命令，正确的说法是（  ）。

A.可触发单步中断   B.将执行完整个程序   C.只能执行一条指令

D.在依次执行完“mov ax,4c00h”、“int 21h”这两条指令后，程序返回

13. mov ax,4c00h

int 21h

这段程序的作用是（ ）。

A.   调用21h号中断例程的4c00h号功能

B.   告诉编译器程序到此结束

C.   返回DOS

D.   前三个选项都不对

14. 正确的说法是（ ）。

    A.可用这段代码读取CMOS中的年份信息

    mov al,9

    in 70h,al

    out al,71h

    B.在移位指令中，可以用bl存储大于1的移位数

    C.用shl指令对al进行移位，要注意对ah的值的影响;

    D.十进制数码的ASCII码=十进制数码的BCD码+30h ；

    E.后面有“：”的地址标号能够写在所有段内

    F.数据标号只能写在数据段内

#### 答案与解析

1. 中断向量表中存放的是 **中断处理程序的入口地址**正确答案: **B**
2. 中断向量占 **4** 字节，正确答案: **D**
3. 错误的描述是 **用汇编语言进行程序设计，子程序一定要用call和ret来实现**。因为子程序也可以通过其他方式实现，例如使用跳转指令。正确答案: **D**
4. 执行后，`al`的值为 **0**，`cf`的值为 **1**。因为 `cl`的值为 `109h`，即 `1001001b`，表示左移 `1001001`位，这会将 `al`中的 `1`左移出去，导致 `al`变为 `0`，并且最后一位移入 `cf`。正确答案: **C**
5. 能实现 `(AX) = (AX) * 8` 的程序段是 **SHL AX,3**。正确答案: **A**
6. 关于 `shl`与 `shr`，正确的说法是 **shr用0补充最高位**。正确答案: **D**
7. 这道题的题目可能有点问题，
   A等价于AX * 6
   B等价于AX * 8
   C等价于AX * 10
   D等价于AX * 64
8. 判断 `AL`的值是否是某个正整数的 `2^n`次方，若 `al=10000110b`，至少需要移位 **4** 位，通过 `cf`的值可判断出结果。正确答案: **D**
9. 中断向量表中存放的是 中断处理程序的入口地址。正确答案: **D**
10. 可以实现将 `ax`的值增大2倍的是 **shl ax,1**。正确答案: **C**
11. 对于8086CPU，正确的指令是 **shl ax,2**。正确答案: **B**
12. 这道题选**A**,t命令指的是单步中断，并不是执行一条指令
13. mov ax,4c00h int 21h` 这段程序的作用是 **返回DOS**正确答案: **C**
14. 正确的说法是 **十进制数码的ASCII码=十进制数码的BCD码+30h**。正确答案: **D**

## 二.用一条指令写出实现下列指明的功能

1. 截取BL寄存器的低4位。
2. 将AX寄存器高4位清0。
3. 将CX 寄存器D14位设置为1，其余位保持不变。
4. 将AL中的低4位代码变反，而其高4位代码不变。
5. 测试AL最低位是否为1。
6. 完成将AX清零，并使标志位CF清零。
7. AX的内容加1。要求不影响CF。
8. 传送25H到AL寄存器。
9. AL内容乘以BL内容。
10. AX内容乘以BX内容。
11. 将AL寄存器值乘2 。
12. AX寄存器的值入栈保存。
13. 把堆栈栈顶数据出栈存入BX寄存器中
14. 标志寄存器的值入栈保存。
15. 把堆栈弹出数据送入标志寄存器中
16. 将BL寄存器值减1。
17. 将BL寄存器值加1。
18. 把数0A0H与AL寄存器的内容相加,并把结果送回AL中。
19. 把数0A0H、AL寄存器和进位标志相加,并把结果送回AL中。
20. 把AX寄存器的值减去数789AH，并把结果送回AX中。
21. 把AX寄存器的值减去数789AH和借位，并把结果送回AX中。
22. 用寄存器BX和SI的基址变址寻址方式，把存储器中的一个字节与AL寄存器的内容相加，并保存在AL寄存器中。
23. 用BX和位移量0B2H的寄存器相对寻址方式把一个字和CX寄存器的内容相加,并把结果送回内存中。
24. 调用7CH中断
25. 把DF标志设置为1
26. 把DF标志清0
27. 把IF标志设置为1
28. 把IF标志清0
29. 当CX为0时，跳转到名为S1的标号处
30. 当上条运算指令结果为正数时，跳转到名为S1的标号处
31. 当上条运算指令结果为负数时，跳转到名为S2的标号处

#### 答案与解析

```assembly
and bl, 0Fh
and ax, 0FFFh
or cx, 4000h
xor al, 0Fh
test al, 1
xor ax, ax
inc ax
mov al, 25h
 mul bl
mul bx
shl al, 1
push ax
pop bx
pushf
popf
dec bl
inc bl
add al, 0A0h
adc al, 0A0h
sub ax, 789Ah
sbb ax, 789Ah
add al, [bx+si]
add [bx+0B2h], cx
int 7Ch
std
cld
sti
cli
jcxz S1
jns S1
js S2
```

## 三.程序分析

1. 以下程序计算2^8，选一个数据补全程序。（  ）

```assembly
assume cs：code

code segment

start： mov ax,2
         mov  cx,_____
    s：  add ax,ax
         loop s
         mov  ax,4c00h
         int  21h
code ends
end start
```

A. 8   B. 7   C. 4   D. 128

2. 如下程序执行后，AX=（  ）。

```assembly
 assume cs：code 

code segment

start： mov ax,2
         mov  bx,2

         mov  cx,0
s： add ax,bx
         loop s
         mov  ax,4c00h
         int  21h
code ends

end start
```

A. 2    B. 4    C. 0FFFEH   D. 0FFFCH

3. 以下指令执行后，10000H~10006H内存单元中的内容是（  ）。

```assembly
 MOV AX,1000H 
 MOV DS,AX 
 MOV BX,0000H 
 MOV AX,3E88H 
 MOV [BX],AX 
 INC BX 
 INC BX 
 MOV [BX],AH 
 MOV AH,0 
 INC BX 
 MOV [BX],AX 
 INC BX 
 MOV [BX],AX 
 MOV AX,DS：[1] 
 INC BX 
 INC BX 
 MOV [BX],AX
```

A.88H,3EH,3EH,88H,88H,00H,3EH

B.88H,3EH,3EH,88H,00H,88H,00H

C.88H,3EH,3EH,88H,00H,3EH,3EH

D.88H,3EH,3EH,88H,88H,3EH,3EH

4. 补全以下程序，计算00101000h-00202000h的值，并将计算结果的高位保存在AX中，低位保存在BX中。（ ）

```assembly
     MOV AX,0010H
     MOV BX,1000H
     ___________
     ___________
```

A.SUB BX,2000H   B.SBB BX,2000H

SUB AX,0020H     SUB AX,0020

C.SUB BX,2000H   D.SBB BX,2000H

SBB AX,0020H    SBB AX,0020H

5. 补全程序，使其可以实现.SUM=字符串STR中的所有BYTE型数据的和。（  ）

```assembly
   ASSUME CS：CODE,ES：DATA

DATA SEGMENT

    STR  DB 'NULL POINTER ASSIGNMENT.'

DATA ENDS

CODE SEGMENT
    SUM  DW   0
START：MOV AX,DATA

         MOV  ____,AX

         MOV  SI,0

         MOV  CX,24

S：MOV AL,STR[SI]

         ADD  ____,AL

         ADC  BYTE PTR SUM[1],0

         LOOP S
  

         MOV  AX,4C00H

         INT  21H

CODE ENDS

END START  
```

A.DS，SUM[2]       B.ES，SUM[2]

C.ES，BYTE PTR SUM[0]  D.DS，BYTE PTR SUM[0]

6. 以下程序实现将data段中的大写字母转换为小写，小写字母转换为大写。补全程序。（  ）

```assembly
 ASSUME CS：CODE

DATA SEGMENT
         DB "heLLo"
DATA ENDS

CODE SEGMENT

START：MOV AX,DATA
         MOV  DS,AX

         MOV  BX,0
         MOV  CX,5
S：ADD BYTE PTR [BX],00100000B ；加上20h，大写变小写，小写多加
         AND  BYTE PTR [BX],_________ ；

         OR   BYTE PTR [BX],01100000B  ；D6D5位置1

         INC  BX

         LOOP S

         MOV  AX,4C00H

         INT  21H
CODE ENDS

END START
```

A.01H   B.00H   C.80H   D.7FH    E.前几个选项都不对

7. 下面的程序统计1000：0处的32个字节型整数中，其值在[-64,-16]中的数据的个数，结果存在DX中。补全这个程序。（ ）

```assembly
mov ax,1000h

mov ds,ax

mov bx,0

mov dx,0

mov cx,32

s：  mov al,0

________

cmp al,16

________

cmp al,64

________

inc dx

s0： inc bx

loop s
```

A.   or al,[bx]；jmp ax；shr al,1

B.   add al,[bx]；jnb s0；jna s0

C.   and al,[bx]；je s0；je s

D.   sub al,[bx]；jb s0；ja s0

E． 前几个选项都不对。

8. 补全程序，使其可以实现将“assembly”复制到0：200处的内存空间中。（  ）

   assume cs：code,ds：data
     data segment
          db 'assembly'
          data ends

    code segment

    start： mov ax,data

    mov ds,ax

    mov si,___

    mov ax,0

    mov es,ax

    mov di,___

    mov cx,___

    std

    rep movsw

    mov ax,4c00h

    int 21h
     code ends
     end start

A.6，206h，4

B.8，208h，4

C.0，200h，8

D.0，200h，4

9. 补全程序，使其可以实现(AX)=2^10。（  ）

 mov ax,2

mov cx,___
s： add ax,ax

   loop s

A.8           B.9           C.10               D.11

10. 以下程序执行后，ax的值是（  ）。

assembly
mov ax,0
push ax

 popf ;标志寄存器值为0

 mov ax,0fff0h

 add ax,88h ;结果是0078H，OF=0,SF=0,ZF=0,PF=1,CF=1

 Pushf  ;标志寄存器压入堆栈

 pop ax ;栈顶弹出一个字到ax，即标志寄存器值

 and al,11000101b ;保留AX的D7（sf） D6（zf） D2（pf） D0（cf）位，其余清0

 and ah,10001000b ;保留AX的D15（0） D11（of）位，其余清0

```

 


参考.标志寄存器

15   14   13   12   11   10   9    8    7    6    5    4     3    2    1    0

                   OF  DF  IF   TF   SF   ZF       AF          PF       CF

 



A. 1h   B. 804h  C. 5h    D. 前三个选项都不对

 
11.   



```assembly
 assume cs：code

stack segment

          db 16 dup(0)

stack ends

code segment

start： mov ax,stack
         mov  ss,ax

         mov  sp,16
         mov  ax,sp

         push cs

         call s

         sub  ax,sp

s：pop ax
         mov  ax,4c00h

         int  21h
code ends

end start
```

这个程序加载到内存后，其一段程序所在的内存空间的情况如下：

内存地址  机器码   所对应的源程序中的指令

1000：0008 8BC4    mov ax,sp

1000：000A 0E     push cs

1000：000B E80200   call s

1000：000E 2BC4    sub ax,sp

1000：0010 58    s：pop ax

执行这个程序，“pop ax”执行后，ax的值为（ ）。

A. 8h   B. 0bh  C. 0eh  D. 1000h  E. 2  F. 10h

12. 以下程序计算(345-333)^2，结果存在dx.ax中。补全这个程序。（  ）

```assembly
 assume cs：code

code segment

start： mov ax,333

         push ax

         mov  ax,345

         push ax

         call calc

 

         mov  ax,4c00h

         int  21h

 

calc： push bp

         mov  bp,sp

         mov  ax,_____

         sub  ax,_____

         mov  bp,ax

         mul  bp

         pop  bp

         ret  4

code ends

end start
```

A.[bp+6]，[bp+8]    B.[bp+4]，[bp+6]

C.[bp+2]，[bp+4]    D.[bp+4]，[bp+2]

13. 以下程序统计0f123：0处的32个字节中，大小在(15，100]的数据的个数，结果存在dx中。补全这个程序。（  ）

```assembly
mov ax,0f123h

mov ds,ax

 

mov bx,0

mov dx,0

mov cx,32

s： mov al,[bx]

cmp al,15

_________

cmp al,100

_________

inc dx

s0：inc bx

loop s
```

14. 以下程序统计0f123：0处的32个字节中，大小在(-100，0）的数据的和，结果存在dx中。补全这个程序。（  ）

```assembly
mov ax,0f123h
mov ds,ax
mov bx,0
mov dx,0
mov cx,32
s： mov al,[bx]
_________
cmp al,-100
_________
cmp al,0

_________

add dx，ax

s0：inc bx

  loop s
```

15. 以下程序执行到(cx)=0时，CPU几次修改IP？（ ）

```assembly
mov cx,2

s ax,bx

loop s
```

 A. 3   B. 5    C. 6   D. 7   E. 8   F. 9

16. 用debug查看内存，结果如下.

 2000：0200 00 01 02 03 04 05 06 07-08 09 0A 0B 0C 0D 0E 0F

2000：0210 10 11 12 13 14 15 16 17-18 19 1A 1B 1C 1D 1E 1F

下面的程序执行后，ax、cx、dx中的内容依次是（  ）。

```assembly
mov ax,1fffh

mov ds,ax

mov ss,ax

mov bx,210h

mov sp,bx

mov ax,[bx] 

mov cx,[bx+12h]

pop dx

 
```

A.未知，未知，未知      B.0100h，1312h，未知

C.0001h，1213h，1415h     D.0100h，1312h，0100h

17. 补全程序，使其可以实现.累加a处的8个数据，结果存在b处的双字中。（  ）

```assembly
assume cs：code,ds：data

data segment

a dw 1,2,3,4,5,6,7,8

b dd 0

c dw a,b

data ends

code segment

 

.......

 

mov ax,4c00h

int 21h

code ends

end start
```

A. start： mov ax,data

mov ds,ax

mov si,0

mov cx,8

s： mov ax,a[si]

add b[0],ax

adc b[2],ax

add si,2

loop s

B. start： mov si,0

mov cx,8

s： mov ax,a[si]

add word ptr b[0],ax

adc word ptr b[2],0

add si,1

loop s

C. start： mov ax,seg a

mov ds,ax

mov si,0

mov cx,8

s： mov ax,a[si]

mov bx,offset b

   add word ptr[bx],ax

adc word ptr 2[bx],0

add si,2

loop s

D. start： mov ax,data

mov ds,ax

mov si,0

mov cx,8

s： mov ax,a[si]

mov bx,word ptr c[0]

add word ptr [bx],ax

mov bx,word ptr c[2]

adc word ptr[bx],0

add si,2

loop s

18. 补全程序，使其可以实现.将data段中的字符串转化为大写。（  ）

assume cs：code

data segment

db 'conversation',0

data ends

code segment

start：

mov ax,data

mov ds,ax

mov si,0

mov cx,12

call capital

mov ax,4c00h

int 21h

capital：

......

code ends

end start

A.   or byte ptr [si],00100000b

inc si

loop capital

ret

B.   mov cl,[si]

mov ch,0

jcxz ok

sub word ptr [si],20h

inc si

inc si

jmp short capital

ok： ret

C.     mov cl,11011111b

s： push cx

and byte ptr [si],cl

inc si

pop cx

loop s

ok： ret

D.   mov cl,[si]

mov ch,0

inc cx

loop ok

ret

ok： and byte ptr [si],11011111b

inc si

jmp capital

19. 以下程序中所有的转移指令的机器码都是两个字节。用一条指令补全程序，使其可以由代码段中的程序段返回。（  ）

```assembly
 assume cs：code
code segment
         mov           ax,4c00h
         int           21h
start：
         nop
         nop
         push          cs
         pop           ds
         mov           si,offset o
         mov           di,offset start
         mov           ax,ds：[si]
         mov           ds：[di],ax
         mov           cx,-2
s：
         jcxz          start
         _____________

o： loop s
code ends
  end start
```

A.add cx,2(机器码：83H C1H 02H)

B.add cx,1(机器码：83H C1H 01H)

C.inc cx(机器码：41H)

D.以上都不对

20. 用debug查看内存单元，结果如下。则执行以下程序，ax的值是多少？（  ）

1100：F000 BE 00 06 00 6A 22

```assembly
      MOV AX,2000H

      MOV DS,AX

      MOV BX,0000H

      MOV SI,0

      MOV AX,2[BX][SI]  

      INC SI

      ADD AX,2[BX][SI]   

      INC SI

      MOV DI,SI

      SUB AX,2[BX][DI]  
```


A.9C06H    B.479CH   C.7006H   D.8C70H

21. 下面的程序执行后，AX中的数值为多少？

内存地址 机器码 汇编指令

1000:0 B8 00 00 MOV AX,0

1000:3 E8 01 00 CALL S

1000:6 40 INC AX

1000:7 58 S:POP AX

22. 下面的程序执行后，AX中的数值为多少？

内存地址 机器码 汇编指令

1000:0 B8 00 00 MOV AX,0

1000:3 9A 09 00 00 10 CALL FAR PTR S

1000:8 40 INC AX

1000:9 58 S:POP AX

ADD AX,AX

POP BX

ADD AX,BX

23. 下面的程序执行后，AX中的数值为多少？

内存地址 机器码 汇编指令

1000:0 B8 06 00 MOV AX,6

1000:2 FF D0 CALL AX

1000:5 40 INC AX

1000:6 MOV BP,SP

ADD AX,[BP]

24. 程序如下。

ASSUME CS:CODE

DATA SEGMENT

？

DATA ENDS

CODE SEGMENT

START: MOV AX,DATA

MOV DS,AX

MOV BX,0

JMP WORD PTR [BX+1]

CODE ENDS

END START

若要使程序中的JMP指令执行后，CS:IP指向程序的第一条指令，在DATA段中应该定义哪些数据?

25. 程序如下。

ASSUME CS:CODE,DS:DATA

DATA SEGMENT

DD 12345678H

DATA ENDS

CODE SEGMENT

START: MOV AX,DATA

MOV DS,AX

MOV BX,0

MOV [BX],_______

MOV [BX+2],_________

JMP DWORD PTR DS:[0]

CODE ENDS

END START

补全程序，使JMP指令执行后，CS:IP指向程序的第一条指令。

26. 用DEBUG查看内存，结果如下：

2000:1000 BE 00 06 00 00 00 ......

则此时，CPU执行指令：

MOV AX,2000H

MOV ES,AX

JMP DWORD PTR ES:[1000H]

后，(CS)=? , (IP)=?

27. 补全下面的程序，统计F000:0处32个字节中，大小在[32,128]的数据的个数。

```assembly
mov ax,0f000h

mov ds,ax

mov bx,0

mov dx,0

mov cx,32

s:mov al,[bx]

cmp al,32

_________

cmp al,120

__________

inc dx

s0:inc bx

loop s
```

28. 补全下面的程序，统计F000:0处32个字节中，大小在(-32,32)的数据的个数。

```assembly
mov ax,0f000h

mov ds,ax

mov bx,0

mov dx,0

mov cx,32

s:mov al,[bx]

cmp al,32

__________

cmp al,120

___________

inc dx

s0:inc bx

loop s
```

(1) 程序如下。

```assembly
assume cs:code

data segment

?

data ends

code segment

start: mov ax,data

mov ds,ax

mov bx,0

jmp word ptr [bx+1]

code ends

end start
```

若要使程序中的jmp指令执行后，CS:IP指向程序的第一条指令，在data段中应该定义哪些数据?

(2) 程序如下。

```assembly
assume cs:code,ds:data

data segment

dd 12345678h

data ends

code segment

start: mov ax,data

mov ds,ax

mov bx,0

_______________________

________________________

jmp dword ptr ds:[0]

code ends

end start
```

补全程序，使jmp指令执行后，CS:IP指向程序的第一条指令。

(3)用Debug查看内存，结果如下：

2000:1000 BE 00 06 00 00 00 ......

则此时，CPU执行指令：

mov ax,2000H

mov es,ax

jmp dword ptr es:[1000H]

后，(CS)=? , (IP)=?

#### 答案与解析

1. 正确答案是 B. 7。2^1 *2^7=2^8,所以循环7次就行
2. AX的初始值是2，BX也是2。程序中没有循环，因此AX的值不会改变。正确答案是 A. 2。
3. C.88H,3EH,3EH,88H,00H,3EH,3EH。
4. 正确的指令是 D. SBB BX,2000H 和 SBB AX,0020H。
5. 正确答案是 D. DS，BYTE PTR SUM[0]。
6. 正确的指令是 AND BYTE PTR [BX],7FH。
7. 正确的指令是 D. sub al,[bx]；jb s0；ja s0。
8. 正确答案是 C.0，200h，8。
9. 正确答案是 B.9。
10. 答案是 B. 804h1。
11. 答案是 A. 8h。
12. 答案是 C. [bp+2]，[bp+4]。
13. 答案是 jg s0 和 jle s0
14. 答案是 test al, al 和 jge s0。
15. 答案是 C. 66。
16. 答案是 C. 0001h，1213h，1415h7。
17. 正确的答案是 **D**。
18. 对于第18题，正确的答案是 **C**。
19. 对于第19题，正确的答案是 **A**。
20. `ax`寄存器的值是 **D.8C70H**。

    后面的都是程序设计，懒得弄了，自己看吧

## 其他

- 教材中的检测点
- 实验1~实验九
